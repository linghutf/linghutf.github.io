<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[欢迎来到linghutf的博客!]]></title>
  <subtitle><![CDATA[林花谢了春红，太匆匆!]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://linghutf.gitcafe.io/"/>
  <updated>2016-06-12T01:34:50.522Z</updated>
  <id>http://linghutf.gitcafe.io/</id>
  
  <author>
    <name><![CDATA[linghutf]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Protobuf使用手册]]></title>
    <link href="http://linghutf.gitcafe.io/2016/06/08/protobuf/"/>
    <id>http://linghutf.gitcafe.io/2016/06/08/protobuf/</id>
    <published>2016-06-08T14:14:18.000Z</published>
    <updated>2016-06-12T01:34:50.522Z</updated>
    <content type="html"><![CDATA[<h2 id="Protobuf_u534F_u8BAE_u6587_u4EF6_u5B9A_u4E49"><a href="#Protobuf_u534F_u8BAE_u6587_u4EF6_u5B9A_u4E49" class="headerlink" title="Protobuf协议文件定义"></a>Protobuf协议文件定义</h2><h3 id="u9009_u62E9_u7248_u672C"><a href="#u9009_u62E9_u7248_u672C" class="headerlink" title="选择版本"></a>选择版本</h3><ul>
<li><code>syntax</code> 声明可以选择protobuf的编译器版本(v2和v3)<ul>
<li><code>syntax=&quot;proto2&quot;;</code>选择2版本，各个字段必须明确标注编号以确定序列化后二进制数据字段的位置</li>
<li><code>syntax=&quot;proto3&quot;;</code>选择3版本,没有强制使用字段编号</li>
</ul>
</li>
</ul>
<h3 id="u5B57_u6BB5_u4FEE_u9970_u7B26"><a href="#u5B57_u6BB5_u4FEE_u9970_u7B26" class="headerlink" title="字段修饰符"></a>字段修饰符</h3><ul>
<li><code>required</code> <ul>
<li>对于required的字段而言，编号初值是必须要提供的，否则字段的便是未初始化的</li>
<li>对于修饰符为required的字段，序列化的时候必须给予初始化,否则程序运行会异常</li>
</ul>
</li>
<li><code>optional</code><ul>
<li>对于optional的字段而言，如果未进行初始化，那么一个默认值将赋予该字段编号</li>
<li>也可以指定默认值,如示例所示.</li>
</ul>
</li>
<li><code>repeated</code><ul>
<li>对于repeated的字段而言，该字段可以重复多个，即每个编码单元可能有多个该字段</li>
<li>在高级语言里面，我们可以通过数组来实现，而在proto定义文件中可以使用repeated来修饰，从而达到相同目的。</li>
<li>当然，出现0次也是包含在内的。</li>
</ul>
</li>
</ul>
<h3 id="u5B57_u6BB5_u7C7B_u578B"><a href="#u5B57_u6BB5_u7C7B_u578B" class="headerlink" title="字段类型"></a>字段类型</h3><table>
<thead>
<tr>
<th style="text-align:center">proto Type</th>
<th style="text-align:center">C++ Type</th>
<th style="text-align:center">Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">int32</td>
<td style="text-align:center">int32</td>
<td style="text-align:center">有符号32位整型数,非固定长度编码,编码效率比sint32低</td>
</tr>
<tr>
<td style="text-align:center">int64</td>
<td style="text-align:center">int64</td>
<td style="text-align:center">有符号64位整型数,非固定长度编码</td>
</tr>
<tr>
<td style="text-align:center">uint32</td>
<td style="text-align:center">uint32</td>
<td style="text-align:center">无符号32位整型数,非固定长度编码</td>
</tr>
<tr>
<td style="text-align:center">uint64</td>
<td style="text-align:center">uint64</td>
<td style="text-align:center">无符号64位整型数,非固定长度编码</td>
</tr>
<tr>
<td style="text-align:center">sint32</td>
<td style="text-align:center">int32</td>
<td style="text-align:center">有符号32位整型数,非固定长度编码,效率较高</td>
</tr>
<tr>
<td style="text-align:center">sint64</td>
<td style="text-align:center">int64</td>
<td style="text-align:center">有符号64位整型数,非固定长度编码,效率较高</td>
</tr>
<tr>
<td style="text-align:center">fixed32</td>
<td style="text-align:center">uint32</td>
<td style="text-align:center">无符号,固定4字节编码,数据大于2^28时,效率比uint32高</td>
</tr>
<tr>
<td style="text-align:center">fixed64</td>
<td style="text-align:center">uint64</td>
<td style="text-align:center">无符号,固定8字节编码,数据大于2^56时,效率比uint32高</td>
</tr>
<tr>
<td style="text-align:center">sfixed32</td>
<td style="text-align:center">int32</td>
<td style="text-align:center">有符号,固定4字节编码</td>
</tr>
<tr>
<td style="text-align:center">sfixed64</td>
<td style="text-align:center">int64</td>
<td style="text-align:center">有符号,固定8字节编码</td>
</tr>
<tr>
<td style="text-align:center">bool</td>
<td style="text-align:center">bool</td>
<td style="text-align:center">布尔值</td>
</tr>
<tr>
<td style="text-align:center">float</td>
<td style="text-align:center">float</td>
<td style="text-align:center">浮点数</td>
</tr>
<tr>
<td style="text-align:center">double</td>
<td style="text-align:center">double</td>
<td style="text-align:center">浮点数</td>
</tr>
<tr>
<td style="text-align:center">string</td>
<td style="text-align:center">string</td>
<td style="text-align:center">必须为UTF-8编码或者7bit ASCII字符串</td>
</tr>
<tr>
<td style="text-align:center">bytes</td>
<td style="text-align:center">string</td>
<td style="text-align:center">字节数组</td>
</tr>
</tbody>
</table>
<h3 id="u5B57_u6BB5_u7C7B_u578B_u5BF9_u5E94_u4E8C_u8FDB_u5236_u7C7B_u578B"><a href="#u5B57_u6BB5_u7C7B_u578B_u5BF9_u5E94_u4E8C_u8FDB_u5236_u7C7B_u578B" class="headerlink" title="字段类型对应二进制类型"></a>字段类型对应二进制类型</h3><table>
<thead>
<tr>
<th style="text-align:center">字段类型</th>
<th style="text-align:center">二进制类型</th>
<th style="text-align:center">二进制编码值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">int32,int64,uint32,uint64,sint32,sint64,bool,enum</td>
<td style="text-align:center">Varint(可变长度int)</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">fixed64,sfixed64,double</td>
<td style="text-align:center">64bit固定长度</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">string,bytes,inner messages(内部嵌套),packaed repeated fields(repeated字段)</td>
<td style="text-align:center">Length-delimited</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">groups(deprecated)</td>
<td style="text-align:center">Start group</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">groups(deprecated)</td>
<td style="text-align:center">Endd group</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">fixed32,sfixed32,float</td>
<td style="text-align:center">32bit固定长度</td>
<td style="text-align:center">5</td>
</tr>
</tbody>
</table>
<h3 id="u6570_u636E_u7F16_u7801_u539F_u5219"><a href="#u6570_u636E_u7F16_u7801_u539F_u5219" class="headerlink" title="数据编码原则"></a>数据编码原则</h3><h4 id="1-Varints_u7F16_u7801_u89C4_u5219"><a href="#1-Varints_u7F16_u7801_u89C4_u5219" class="headerlink" title="1.Varints编码规则"></a>1.Varints编码规则</h4><ul>
<li>protobuf编码基础是Varints,Varints是将一个整数序列化为一个或多个Bytes的方法,越小的整数，使用的Bytes越少<ul>
<li>每个byte最高位(msb)是标志位,0表示是最后一个byte,1表示该字段值还有后续byte</li>
<li>每个byte低7位存放数值</li>
<li>Varints使用Little Endian(小端)字节序</li>
</ul>
</li>
<li>转换示例</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dec(<span class="number">300</span>) </span><br><span class="line">=&gt; bin(<span class="number">00000001</span> <span class="number">00101100</span>) </span><br><span class="line">=&gt; Little(<span class="number">00101100</span> <span class="number">00000001</span>) </span><br><span class="line">=&gt; Encode(<span class="number">10101100</span> <span class="number">00000010</span>)</span><br></pre></td></tr></table></figure>
<h4 id="2-_u6D88_u606F_u7F16_u7801_u89C4_u5219"><a href="#2-_u6D88_u606F_u7F16_u7801_u89C4_u5219" class="headerlink" title="2.消息编码规则"></a>2.消息编码规则</h4><ul>
<li>message都是以一组或多组key-value对组成,key和value分别采用不同的编码方式</li>
<li>序列化时，将message中所有key-value序列化成二进制字节流。反序列化时，解析出所有key-value对，<br>如果遇到无法识别的类型，则直接跳过。这种机制保证了旧有的编/解码在协议添加新的字段时，依旧可以正常工作</li>
<li>key由两部分组成，一部分是在定义消息时对字段的编号（field_num），另一部分是字段类型（wire_type，编号最大不超过<code>536870911</code>.</li>
<li>key编码方式<code>filed_num&lt;&lt;3|wire_type</code>，编码后的二进制长度是<code>变长</code>的</li>
<li>varint(wire_type=0)编码规则:<ul>
<li>int32,int64直接按照varint方法来编码,因此-1,-2这种负数由于补码数表示有很多1,所占的byte也比较多</li>
<li>sint32,sint64采用<code>Zigzag</code>方法来避免上述问题</li>
<li>首先采用Zigzag方法，将正数、0和负数映射到无符号数上</li>
<li>再采用varint编码方法</li>
<li><code>Zigzag</code>映射规则</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Zigzag(n) = (n&lt;&lt;<span class="number">1</span>)^(n&gt;&gt;<span class="number">31</span>) ,n为sint32时</span><br><span class="line">Zigzag(n) = (n&lt;&lt;<span class="number">1</span>)^(n&gt;&gt;<span class="number">63</span>) ,n为sint64时</span><br></pre></td></tr></table></figure>
<ul>
<li>映射值表</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">Original(原始值)</th>
<th style="text-align:center">(编码后的值)EncodeAs</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">-1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">-2</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">-3</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">2147483647</td>
<td style="text-align:center">4294967294</td>
</tr>
<tr>
<td style="text-align:center">-2147483648</td>
<td style="text-align:center">4294967295</td>
</tr>
</tbody>
</table>
<ul>
<li>64bit(wire_type=1)和32bit(wire_type=5)编码是在key后跟上Little Endian字节的数值</li>
<li><p>string,bytes都属于length-delimited编码,length-delimited(wire_type=2)的编码方式：key+length+content</p>
<ul>
<li>key的编码方式是统一的</li>
<li>length采用varints编码方式</li>
<li>content就是由length指定的长度的Bytes</li>
</ul>
</li>
<li><p>完整示例</p>
<ul>
<li><p>type.proto</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">message IntType &#123;</span><br><span class="line">	optional int32 a_i32 = <span class="number">1</span>;</span><br><span class="line">	optional int64 b_i64 = <span class="number">2</span>;</span><br><span class="line">	optional sint32 c_s32 = <span class="number">3</span>;</span><br><span class="line">	optional sint64 d_s64 = <span class="number">4</span>;</span><br><span class="line">	optional sfixed32 e_sf32 = <span class="number">5</span>;</span><br><span class="line">	optional sfixed64 f_sf64 = <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message UIntType &#123;</span><br><span class="line">	optional uint32 a_u32 = <span class="number">1</span>;</span><br><span class="line">	optional uint64 b_u64 = <span class="number">2</span>;</span><br><span class="line">	optional fixed32 c_f32 = <span class="number">3</span>;</span><br><span class="line">	optional fixed64 d_f64 = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message FType&#123;</span><br><span class="line">	optional <span class="keyword">float</span> a_f = <span class="number">1</span>;</span><br><span class="line">	optional <span class="keyword">double</span> b_d = <span class="number">2</span>;</span><br><span class="line">	optional <span class="keyword">bool</span> c_b = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message BSType&#123;</span><br><span class="line">	optional <span class="built_in">string</span> a_s = <span class="number">1</span>;</span><br><span class="line">	repeated bytes b_bs = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>初始值</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//int</span></span><br><span class="line">type::IntType it;</span><br><span class="line">it.set_a_i32(-<span class="number">1</span>);</span><br><span class="line">it.set_b_i64(-<span class="number">1</span>);</span><br><span class="line">it.set_c_s32(-<span class="number">1</span>);</span><br><span class="line">it.set_d_s64(-<span class="number">1</span>);</span><br><span class="line">it.set_e_sf32(-<span class="number">1</span>);</span><br><span class="line">it.set_f_sf64(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//uint</span></span><br><span class="line">type::UIntType ut;</span><br><span class="line">ut.set_a_u32(<span class="number">1</span>);</span><br><span class="line">ut.set_b_u64(<span class="number">2</span>);</span><br><span class="line">ut.set_c_f32(<span class="number">1</span>);</span><br><span class="line">ut.set_d_f64(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//float</span></span><br><span class="line">type::FType ft;</span><br><span class="line">ft.set_a_f(<span class="number">0.1</span>);</span><br><span class="line">ft.set_b_d(<span class="number">0.2</span>);</span><br><span class="line">ft.set_c_b(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//bytes</span></span><br><span class="line">type::BSType bt;</span><br><span class="line">bt.set_a_s(<span class="string">"hello,world."</span>);</span><br><span class="line">bt.add_b_bs(<span class="string">"h"</span>);</span><br><span class="line">bt.add_b_bs(<span class="string">"0x1"</span>);</span><br><span class="line">bt.add_b_bs(<span class="string">"d"</span>);</span><br><span class="line">bt.add_b_bs(<span class="string">"ILV"</span>);</span><br><span class="line">bt.add_b_bs(<span class="string">"0xf"</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>二进制表示</p>
<ul>
<li><p>IntType</p>
<p>| 类型 |  key | EncodedAs key | value  | EncodedAs value | EncodedAs String | Notes |<br>| :–: | :–: | :————: | :—: | :————-: | :—: | :—: |<br>| int32 | 1   | <code>1&lt;&lt;3 OR 0 = 00001000</code> |  -1  | 11111111(9 times) 00000001 | 00001000 11111111(9times) 00000001 | varints编码 |<br>| int64 | 2   | <code>2&lt;&lt;3 OR 0 = 00010000</code> |  -1  | 11111111(9 times) 00000001 | 00010000 11111111(9times) 00000001 | varints编码 |<br>| sint32 | 3   | <code>3&lt;&lt;3 OR 0 = 00011000</code> |  -1  | 00000001 | 00011000 00000001| 无符号变换 |<br>| sint32 | 4   | <code>4&lt;&lt;3 OR 0 = 00100000</code> |  -1  | 00000001 | 00100000 00000001| 无符号变换 |<br>| sfixed32 | 5   | <code>5&lt;&lt;3 OR 5 = 00101101</code> |  -1  | 11111111(4 times) | 00011000 11111111 11111111 11111111 11111111 | 固定4byte长度 |<br>| sfixed32 | 6   | <code>6&lt;&lt;3 OR 1 = 00110001</code> |  -1  | 11111111(8 times) | 00011000 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 | 固定8byte长度 |</p>
</li>
<li><p>UIntType</p>
<p>| 类型 |  key | EncodedAs key | value  | EncodedAs value | EncodedAs String | Notes |<br>| :–: | :–: | :————: | :—: | :————-: | :—: | :—: |<br>| uint32 | 1   | <code>1&lt;&lt;3 OR 0 = 00001000</code> |  1  | 00000001 | 00001000 00000001| 无符号 |<br>| uint64 | 2   | <code>2&lt;&lt;3 OR 0 = 00010000</code> |  2  | 00000010 | 00010000 00000010| 无符号 |<br>| fixed32 | 3   | <code>3&lt;&lt;3 OR 5 = 00011101</code> |  1  | 00000001 00000000(3 times) | 00011101 00000001 00000000(3 times) | 固定4byte长度 |<br>| fixed64 | 4   | <code>4&lt;&lt;3 OR 1 = 00100001</code> |  2  | 00000010 00000000(7 times) | 00011101 00000001 00000000(7 times) | 固定8byte长度 |</p>
</li>
<li><p>FType  </p>
<p>| 类型 |  key | EncodedAs key | value  | EncodedAs value | EncodedAs String | Notes |<br>| :–: | :–: | :————: | :—: | :————-: | :—: | :—: |<br>| float | 1   | <code>1&lt;&lt;3 OR 5 = 00001101</code> |  0.1  | 11001101 11001100 11001100 00111101 | 00001101 11001101 11001100 11001100 00111101 | IEEE浮点数,4byte |<br>| double | 2   | <code>2&lt;&lt;3 OR 1 = 00010001</code> |  0.2  | 10011010 10011001 10011001 10011001 10011001 10011001 11001001 00111111 | 00010001 10011010 10011001 10011001 10011001 10011001 10011001 11001001 00111111| IEEE浮点数,8byte |<br>| bool | 3 | <code>3&lt;&lt;3 OR 0 = 00011000</code> | false | 00000000 | 00011000 00000000 | 固定1byte长度 |</p>
</li>
<li><p>BSType</p>
<p>| 类型 |  key | EncodedAs key | value  | EncodedAs value | EncodedAs String | Notes |<br>| :–: | :–: | :————: | :—: | :————-: | :—: | :—: |<br>| string | 1 | <code>1&lt;&lt;3 OR 2 = 00001010</code> | “hello,world.” | 00001100(length) 01101000 01100101 01101100 01101100 01101111 00101100 01110111 01101111 01110010 01101100 01100100 00101110(ASCII) | length+content编码 |<br>| bytes | 2 | <code>2&lt;&lt;3 OR 2 = 00010010</code> | “h”,”0x1”,”d”,”ILV”,”0xf” | 00000001 01101000 00010010 00000011 00110000 01111000 00110001 00010010 00000001 01100100 00010010 00000011 01001001 01001100 01010110 00010010 00000011 00110000 01111000 01100110 | 符号分割 |</p>
</li>
</ul>
</li>
</ul>
<h4 id="3-_u7F16_u89E3_u7801_u5B57_u6BB5_u987A_u5E8F"><a href="#3-_u7F16_u89E3_u7801_u5B57_u6BB5_u987A_u5E8F" class="headerlink" title="3.编解码字段顺序"></a>3.编解码字段顺序</h4><ul>
<li>编解码与字段顺序无关,由key-value机制就能保证</li>
<li>对于未知的字段，编码的时候会把它写在序列化完的已知字段后面</li>
</ul>
<h3 id="u5D4C_u5957_u4E0E_u5F15_u7528"><a href="#u5D4C_u5957_u4E0E_u5F15_u7528" class="headerlink" title="嵌套与引用"></a>嵌套与引用</h3><h4 id="1-_u5D4C_u5957_u5B9A_u4E49"><a href="#1-_u5D4C_u5957_u5B9A_u4E49" class="headerlink" title="1.嵌套定义"></a>1.嵌套定义</h4><ul>
<li><code>message</code>定义中可以嵌套定义<code>message</code>,<code>enum</code></li>
<li>嵌套定义的单元外部可见，引用路径由外到内逐层引用</li>
</ul>
<h4 id="2-_u5F15_u7528"><a href="#2-_u5F15_u7528" class="headerlink" title="2.引用"></a>2.引用</h4><ul>
<li>定义<code>package</code>相当于C++的<code>namespace</code>,外部引用时需要package名</li>
<li>引用外部message定义，只需要<code>import</code>外部proto文件即可使用</li>
<li>引用使用相对路径,生成文件时protobuf可以自动处理</li>
</ul>
<h3 id="u5B8C_u6574_u793A_u4F8B"><a href="#u5B8C_u6574_u793A_u4F8B" class="headerlink" title="完整示例"></a>完整示例</h3><ul>
<li>user.proto</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//user.proto</span><br><span class="line"></span><br><span class="line">syntax="proto2“;</span><br><span class="line">package user;</span><br><span class="line"></span><br><span class="line">message User&#123;</span><br><span class="line">    required sfixed64 uid = 1;</span><br><span class="line">    </span><br><span class="line">    enum PhoneType&#123;</span><br><span class="line">        NONE = 1;</span><br><span class="line">        HOME = 2;</span><br><span class="line">        MOBILE = 3;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    message PhoneNumber &#123;</span><br><span class="line">        required string number = 1;</span><br><span class="line">        optional PhoneType type = 2 [default = MOBILE];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    repeated PhoneNumber phone = 2;</span><br><span class="line">    </span><br><span class="line">    optional sfixed32 age = 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Admin &#123;</span><br><span class="line">    required sfixed64 uid = 1;</span><br><span class="line">    optional User.PhoneNumber phone = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>room.proto</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//room.proto</span></span><br><span class="line"></span><br><span class="line">syntax=<span class="string">"proto2"</span>;</span><br><span class="line">package room;</span><br><span class="line"></span><br><span class="line">import <span class="string">"relative_dir/user.proto"</span>;</span><br><span class="line"></span><br><span class="line">message Room &#123;</span><br><span class="line">    repeated sfixed64 rid = <span class="number">1</span>;</span><br><span class="line">    repeated user.User user = <span class="number">2</span>;</span><br><span class="line">    optional <span class="keyword">double</span> profit = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Protobuf_u7F16_u8BD1_u4F7F_u7528"><a href="#Protobuf_u7F16_u8BD1_u4F7F_u7528" class="headerlink" title="Protobuf编译使用"></a>Protobuf编译使用</h2><ul>
<li>由协议生成C++文件:<code>protoc --cpp_out=${DIR} proto-file...</code></li>
<li>多个协议文件依赖关系:<code>protoc --cpp_out=${DIR} base-proto-file deliver-proto-file...</code></li>
<li>依赖问题按相对路径处理import即可解决</li>
</ul>
<h3 id="cmake_u81EA_u52A8_u5316_u7F16_u8BD1"><a href="#cmake_u81EA_u52A8_u5316_u7F16_u8BD1" class="headerlink" title="cmake自动化编译"></a><code>cmake</code>自动化编译</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FIND_PACKAGE(Protobuf REQUIRED)</span><br><span class="line">LINK_LIBRARIES(</span><br><span class="line">    protobuf</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">FILE(GLOB ProtoFiles RELATIVE $&#123;CMAKE_CURRENT_SOURCE_DIR&#125; *.proto)</span><br><span class="line">PROTOBUF_GENERATE_CPP(PROTO_SRCS PROTO_HDRS $&#123;ProtoFiles&#125; )</span><br></pre></td></tr></table></figure>
<h2 id="Protobuf_u5E8F_u5217_u5316_u4E0E_u53CD_u5E8F_u5217_u5316"><a href="#Protobuf_u5E8F_u5217_u5316_u4E0E_u53CD_u5E8F_u5217_u5316" class="headerlink" title="Protobuf序列化与反序列化"></a>Protobuf序列化与反序列化</h2><h3 id="1-_u521D_u59CB_u5316"><a href="#1-_u521D_u59CB_u5316" class="headerlink" title="1.初始化"></a>1.初始化</h3><ul>
<li><code>set_xxx()</code>设置<code>required</code>,<code>optional</code>字段值</li>
<li><code>add_xxx()</code>添加<code>repeated</code>字段值</li>
<li><code>set_xxx(int,x)</code>设置<code>repeated</code>中元素的值</li>
</ul>
<h3 id="2-_u5E8F_u5217_u5316"><a href="#2-_u5E8F_u5217_u5316" class="headerlink" title="2.序列化"></a>2.序列化</h3><ul>
<li><code>required</code>字段需要初始化,可以通过<code>IsInitialized</code>来检查是否完成message对象的初始化</li>
<li><code>SerializedAsString()</code>,<code>SerializedToString(std::string*)</code>序列化为std::string</li>
<li><code>SerializedToArray(void*,int)</code>序列化为byte数组</li>
<li><code>SerializedToOstream(ostream*)</code>序列化到输出流</li>
<li><code>ByteSize()</code>获取二进制字节序的大小，可用于初始化存放容器</li>
</ul>
<h3 id="3-_u53CD_u5E8F_u5217_u5316"><a href="#3-_u53CD_u5E8F_u5217_u5316" class="headerlink" title="3.反序列化"></a>3.反序列化</h3><ul>
<li><code>ParseFromString(std::string&amp; data)</code>从字符串中反序列化</li>
<li><code>ParseFromArray(const void *,int)</code>从字节序中反序列化</li>
<li><code>ParseFromIstream(istream*)</code>从输入流中反序列化</li>
<li><code>has_xxx()</code>用于检查相应字段是否存在数据</li>
<li><code>xxx_size()</code>用于确定<code>repeated</code>字段是否存在，0表示未序列化</li>
</ul>
<h3 id="4-_u83B7_u53D6_u5BF9_u8C61"><a href="#4-_u83B7_u53D6_u5BF9_u8C61" class="headerlink" title="4.获取对象"></a>4.获取对象</h3><ul>
<li><code>xxx()</code>返回<code>required/optional</code>字段的<code>const</code>值,只读模式，返回<code>repeated</code>列表的指针,用于修改</li>
<li><code>mutable_xxx()</code>返回字段指针,用于修改</li>
<li><code>xxx(int)</code>返回<code>repeated</code>字段列表的元素,只读</li>
</ul>
<h2 id="protobuf_u5B9E_u73B0_u539F_u7406"><a href="#protobuf_u5B9E_u73B0_u539F_u7406" class="headerlink" title="protobuf实现原理"></a>protobuf实现原理</h2><h3 id="1-protobuf_u7684cache_u673A_u5236"><a href="#1-protobuf_u7684cache_u673A_u5236" class="headerlink" title="1.protobuf的cache机制"></a>1.protobuf的cache机制</h3><ul>
<li>protobuf message的clear()操作是存在cache机制的，它并不会释放申请的空间，这导致占用的空间越来越大。</li>
<li>如果程序中protobuf message占用的空间变化很大，那么最好每次或定期进行清理。这样可以避免内存不断的上涨。</li>
</ul>
<h2 id="u6CE8_u610F_u4E8B_u9879"><a href="#u6CE8_u610F_u4E8B_u9879" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li>嵌套定义时，被嵌套的结构体被解析成A_B形式,需要获取<code>mutable_b()</code>指针来初始化该字段,使用栈上的对象会导致程序异常</li>
<li>应用程序中使用protobuf,需要在退出程序时调用<code>google::protobuf::ShutdownProtobufLibrary()</code>以清理内存,否则会造成内存泄漏</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Protobuf_u534F_u8BAE_u6587_u4EF6_u5B9A_u4E49"><a href="#Protobuf_u534F_u8BAE_u6587_u4EF6_u5B9A_u4E49" class="headerlink" title="Prot]]>
    </summary>
    
      <category term="c++" scheme="http://linghutf.gitcafe.io/tags/c/"/>
    
      <category term="cmake" scheme="http://linghutf.gitcafe.io/tags/cmake/"/>
    
      <category term="protobuf" scheme="http://linghutf.gitcafe.io/tags/protobuf/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[TCP传输文件和对象序列化]]></title>
    <link href="http://linghutf.gitcafe.io/2016/05/06/TCP%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://linghutf.gitcafe.io/2016/05/06/TCP传输文件和对象序列化/</id>
    <published>2016-05-06T02:48:09.000Z</published>
    <updated>2016-05-06T02:48:40.000Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
      <category term="TCP" scheme="http://linghutf.gitcafe.io/tags/TCP/"/>
    
      <category term="golang" scheme="http://linghutf.gitcafe.io/tags/golang/"/>
    
      <category term="serialization" scheme="http://linghutf.gitcafe.io/tags/serialization/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HashTable实现]]></title>
    <link href="http://linghutf.gitcafe.io/2016/04/21/HashTable/"/>
    <id>http://linghutf.gitcafe.io/2016/04/21/HashTable/</id>
    <published>2016-04-21T08:19:30.000Z</published>
    <updated>2016-04-21T08:20:21.000Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++11多线程同步互斥初探]]></title>
    <link href="http://linghutf.gitcafe.io/2016/03/20/C++11%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5%E5%88%9D%E6%8E%A2/"/>
    <id>http://linghutf.gitcafe.io/2016/03/20/C++11多线程同步互斥初探/</id>
    <published>2016-03-20T08:14:41.000Z</published>
    <updated>2016-03-20T08:15:47.000Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
      <category term="STL" scheme="http://linghutf.gitcafe.io/tags/STL/"/>
    
      <category term="c++" scheme="http://linghutf.gitcafe.io/tags/c/"/>
    
      <category term="mutex" scheme="http://linghutf.gitcafe.io/tags/mutex/"/>
    
      <category term="thread" scheme="http://linghutf.gitcafe.io/tags/thread/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[位图解决海量数据排序问题]]></title>
    <link href="http://linghutf.gitcafe.io/2016/03/10/C++%E4%BD%8D%E5%9B%BE%E6%8E%92%E5%BA%8F%E8%A7%A3%E5%86%B3%E4%BA%BF%E7%BA%A7%E6%95%B0%E9%87%8F%E9%97%AE%E9%A2%98/"/>
    <id>http://linghutf.gitcafe.io/2016/03/10/C++位图排序解决亿级数量问题/</id>
    <published>2016-03-10T03:12:43.000Z</published>
    <updated>2016-04-11T03:49:34.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u95EE_u9898_u6765_u6E90"><a href="#u95EE_u9898_u6765_u6E90" class="headerlink" title="问题来源"></a><strong>问题来源</strong></h2><p>  在实际运用场景里，经常会遇到把大量数据有序输出，文件的排序等等问题。一般的排序算法针对数据量不大的情况下，二叉树排序和快速排序针对现实中的随机数据时间复杂度为O(NlgN),性能表现已经很不错了，因此这两种方法被广泛使用。<br>  但是，在企业级数据量情况下，这两种排序耗费的时间就会显著增长，以至需要非常长的时间才能得到结果，而且在排序的过程中，由于插入和选择结点的操作会使得CPU满负荷工作，这对于长期工作的服务器来说是不利的。<br>  因此，在这种海量数据排序的需求刺激下，产生了一种简易的”哈希”方法，那就是位图排序。</p>
<h2 id="u6392_u5E8F_u601D_u60F3"><a href="#u6392_u5E8F_u601D_u60F3" class="headerlink" title="排序思想"></a><strong>排序思想</strong></h2><p>  位图排序的思想非常简单，那就是将一个个数据映射到它在有序的数轴上的一点，这个数轴可以是一个数组，数字的大小就是哈希因子，所以在遍历一遍数据集，设置好这些数字的点表示之后，我们就可以根据相应位置的状态，反过来来确定数据集中是否有这个数字，由于我们是有序的遍历的，因此查找出来的数字也是有序的，这样间接地达到了我们的目的。<br>  位图很像数学中的数轴的概念，有哪些数字，就会在相应的位置标记它们，最后数据都是有序的。而且这种方法，一个数字占用的位置只有一个bit,对于0~2&lt;&lt;32的4字节非负整数范围来说，最大的数为42亿，在实际应用场景下基本足够，而所需要的空间占用大概只需要2&lt;&lt;32/8/1024^2=512M的内存，在内存占用上和效率上都有着无可比拟的优势。</p>
<h2 id="u5B9E_u9645_u6D4B_u8BD5"><a href="#u5B9E_u9645_u6D4B_u8BD5" class="headerlink" title="实际测试"></a><strong>实际测试</strong></h2><p>说了这么多，当然需要实际测试一番，才能证明位图排序真的在海量数据排序上具有优势。<br>例如在我的服务器上，随机生成1000W个整数，现在需要将它们排序。那么对于快速排序，二叉树排序和位图排序，分别需要多少时间呢？</p>
<blockquote>
<ul>
<li>机器环境GCC5.3.1,编译参数-std=c++11 -O3</li>
<li>源代码详见<a href="https://github.com/linghutf/topcoder/blob/master/blog/Sort.cc" target="_blank" rel="external">topcoder</a></li>
</ul>
</blockquote>
<p>###1. <strong>快排</strong></p>
<ul>
<li>主要分为partiiton和sort两个阶段，使用STL自带的快排实现</li>
<li>注意,STL的sort会在递归sort层数过多时变成堆排序，虽然时间复杂度都是O(NlgN),但是这种测试只是作为一种参考</li>
<li>而且系统在每一次递归调用时都会保存栈信息，递归层数太多会导致栈溢出。所以，在海量数据排序一次性排序中，使用快排并不现实。基本都会借助归并的思想去分块排序然后合并。<br><img src="http://7xr8se.com1.z0.glb.clouddn.com/huge_qsort.png" alt="qsort"><h5 id="STL_u7684sort_u6240_u7528_u65F6_u95F4"><a href="#STL_u7684sort_u6240_u7528_u65F6_u95F4" class="headerlink" title="STL的sort所用时间"></a>STL的sort所用时间</h5><script src="https://gist.github.com/linghutf/4a0ab262600edda6f944b3eb95569ee9.js?file=quicksort.cc"></script>

</li>
</ul>
<p>###2. <strong>二叉树排序</strong></p>
<ul>
<li>测试中使用的红黑树实现的有序multiset,由于红黑树查询、删除、插入的时间复杂度均为O(lgK),因此遍历一遍数据之后时间复杂度就是O(NlgN)了</li>
<li>但是可能在茶如大量数据时频繁创建和改变节点属性，因此综合性能可能不如快速排序。以下的时间即可说明这个问题。<br><img src="http://7xr8se.com1.z0.glb.clouddn.com/huge_hashsort.png" alt="hashsort"><h5 id="u7EA2_u9ED1_u6811_u5B9E_u73B0_u7684_u6392_u5E8F_u6240_u7528_u65F6_u95F4"><a href="#u7EA2_u9ED1_u6811_u5B9E_u73B0_u7684_u6392_u5E8F_u6240_u7528_u65F6_u95F4" class="headerlink" title="红黑树实现的排序所用时间"></a>红黑树实现的排序所用时间</h5><script src="https://gist.github.com/linghutf/4a0ab262600edda6f944b3eb95569ee9.js?file=hashsort.cc"></script>

</li>
</ul>
<p>###3. <strong>位图排序</strong></p>
<ul>
<li>位图排序可以看做是一种特殊的哈希排序。使用元素数值作为哈希函数</li>
<li>但是这种方法在有重复元素的环境下，需要在遍历设置位图状态时，记录重复元素的个数。</li>
<li>另一个问题就是C/C++程序运行时分配的栈空间是有限制的，分配几百M的内存运行时就会报错，所以我们需要使用dynamic_bitset,这种动态bitset由boost库实现，是在堆上分配的内存，因此突破了限制。<br>-与bitset不同之处还有dynamic_bitset的set效率没有STL bitset高。</li>
</ul>
<p><img src="http://7xr8se.com1.z0.glb.clouddn.com/huge_bitsort.png" alt="bitsort"></p>
<h5 id="u4F4D_u56FE_u5B9E_u73B0_u7684_u6392_u5E8F_u6240_u7528_u65F6_u95F4"><a href="#u4F4D_u56FE_u5B9E_u73B0_u7684_u6392_u5E8F_u6240_u7528_u65F6_u95F4" class="headerlink" title="位图实现的排序所用时间"></a>位图实现的排序所用时间</h5><script src="https://gist.github.com/linghutf/4a0ab262600edda6f944b3eb95569ee9.js?file=bitsort.cc"></script>

<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a><strong>总结</strong></h2><ol>
<li>在上面的结果中，可以看出，因为快排不是单纯地快排，STL内部的内存分配等都有优化，因此出现了比位图排序快的情况</li>
<li>在海量数据情况，一次将数据排序是不可能的，因此这次的测试规模只是反映一种简单的比较。实际情况中，需要结合排序和分治的思想。</li>
<li>位图排序的用途不只是排序，由于它每个比较的单元只占用1bit,很适合处理大量数据和文件的问题，在Linux的多路复用I/O函数select中,它作为文件描述符的状态集使用，每次查询bit位数值就可以判断相应文件描述符IO状态。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u95EE_u9898_u6765_u6E90"><a href="#u95EE_u9898_u6765_u6E90" class="headerlink" title="问题来源"></a><strong>问题来源</strong></h2><p>  在实际运用]]>
    </summary>
    
      <category term="algorithm" scheme="http://linghutf.gitcafe.io/tags/algorithm/"/>
    
      <category term="c++" scheme="http://linghutf.gitcafe.io/tags/c/"/>
    
      <category term="sort" scheme="http://linghutf.gitcafe.io/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[STL的有序和无序哈希容器]]></title>
    <link href="http://linghutf.gitcafe.io/2016/03/06/STL%E7%9A%84%E6%9C%89%E5%BA%8F%E5%92%8C%E6%97%A0%E5%BA%8F%E5%93%88%E5%B8%8C%E5%AE%B9%E5%99%A8/"/>
    <id>http://linghutf.gitcafe.io/2016/03/06/STL的有序和无序哈希容器/</id>
    <published>2016-03-06T13:22:26.000Z</published>
    <updated>2016-03-06T13:22:53.000Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
      <category term="C++" scheme="http://linghutf.gitcafe.io/tags/C/"/>
    
      <category term="HashMap" scheme="http://linghutf.gitcafe.io/tags/HashMap/"/>
    
      <category term="STL" scheme="http://linghutf.gitcafe.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux下C/C++动态库的生成和加载]]></title>
    <link href="http://linghutf.gitcafe.io/2016/03/06/Linux%E4%B8%8BC-C-%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E7%94%9F%E6%88%90%E5%92%8C%E5%8A%A0%E8%BD%BD/"/>
    <id>http://linghutf.gitcafe.io/2016/03/06/Linux下C-C-动态库的生成和加载/</id>
    <published>2016-03-06T13:19:37.000Z</published>
    <updated>2016-03-06T13:20:30.000Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
      <category term="C" scheme="http://linghutf.gitcafe.io/tags/C/"/>
    
      <category term="C++" scheme="http://linghutf.gitcafe.io/tags/C/"/>
    
      <category term="Linux" scheme="http://linghutf.gitcafe.io/tags/Linux/"/>
    
      <category term="Makefile" scheme="http://linghutf.gitcafe.io/tags/Makefile/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++四种转型cast]]></title>
    <link href="http://linghutf.gitcafe.io/2016/03/06/C++%E5%9B%9B%E7%A7%8D%E8%BD%AC%E5%9E%8Bcast/"/>
    <id>http://linghutf.gitcafe.io/2016/03/06/C++四种转型cast/</id>
    <published>2016-03-06T13:17:41.000Z</published>
    <updated>2016-03-06T13:18:32.000Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
      <category term="C++" scheme="http://linghutf.gitcafe.io/tags/C/"/>
    
      <category term="基础技术" scheme="http://linghutf.gitcafe.io/tags/%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[个人密码存储在线服务]]></title>
    <link href="http://linghutf.gitcafe.io/2016/02/25/secretsys-md/"/>
    <id>http://linghutf.gitcafe.io/2016/02/25/secretsys-md/</id>
    <published>2016-02-25T04:22:29.000Z</published>
    <updated>2016-02-25T13:09:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="u4E2A_u4EBA_u521D_u8877"><a href="#u4E2A_u4EBA_u521D_u8877" class="headerlink" title="个人初衷"></a>个人初衷</h1><blockquote>
<ul>
<li>随着互联网使用的时间增长，自己在网上的账号越来越多，但因为之前就注重安全功能，<br>所以我很少使用同一套账号系统。所以账号数量越来越多导致我难以记住，而且很多信息比<br>如网银包含有账号之外的安全信息。虽然chrome有记住密码功能，但一些安全问题，保密安全<br>码它都无能为力。</li>
<li>之前考虑过使用1Password等软件，有些是有使用环境限制，而且不知道运作方式，不知道会不<br>会丢失或被攻击者窃取个人信息，这也是我想自己完全掌握自己的个人信息安全的原因。</li>
<li>基于以上因素，我萌生了开发一套在线密码管理系统，这样既省略了同步因素，还能随时查询，<br>不用的时候导出文件就可以了。</li>
</ul>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u4E2A_u4EBA_u521D_u8877"><a href="#u4E2A_u4EBA_u521D_u8877" class="headerlink" title="个人初衷"></a>个人初衷</h1><blockquote>
<ul>
<li>随着互联网]]>
    </summary>
    
      <category term="aes" scheme="http://linghutf.gitcafe.io/tags/aes/"/>
    
      <category term="beego" scheme="http://linghutf.gitcafe.io/tags/beego/"/>
    
      <category term="go" scheme="http://linghutf.gitcafe.io/tags/go/"/>
    
      <category term="html" scheme="http://linghutf.gitcafe.io/tags/html/"/>
    
      <category term="javascript" scheme="http://linghutf.gitcafe.io/tags/javascript/"/>
    
      <category term="mysql" scheme="http://linghutf.gitcafe.io/tags/mysql/"/>
    
      <category term="server" scheme="http://linghutf.gitcafe.io/tags/server/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在外的元宵节]]></title>
    <link href="http://linghutf.gitcafe.io/2016/02/22/20160222/"/>
    <id>http://linghutf.gitcafe.io/2016/02/22/20160222/</id>
    <published>2016-02-22T08:31:53.000Z</published>
    <updated>2016-02-22T12:42:54.000Z</updated>
    <content type="html"><![CDATA[<p>　　春节假期转眼就过去了，感觉是过得最快的一个春节。马上又面临新的挑战，正处在一个学习<br>和工作的过渡期，莫名的烦心事和压力随之而来。开学时间很早，之前所有相聚的年轻人一股脑儿<br>全离开了，为了明年的春节聚首又回到城市奋斗，看得让人心慌，想到未来我在哪里，是否也像他<br>们一般匆匆来去?现在的娱乐方式多不胜数，但是人的情绪来源越来越少，仿佛只有通往金钱的道路<br>才能让人心旷神怡，只有人人羡慕的生活才是成功的人生。在这种环境下，假期像是一场鸵鸟的避风<br>动作，暂时没有烦恼，心却没有安宁下来。于是，剩下的日子，终于像风一样迅速消失在心灵的沙漠<br>中。<br>　　元宵节之前的几天，我就已经来到了实验室，开始了日复一日的工作，和同年人继续没有交流却<br>保持默契地竞争。突然发现，原来节日本为人带来欢乐的意义就是这样丢失的。你还有很多工作，前方<br>还有许多美好的憧憬在你到达之后才能实现，于是你忽略了路边的景色，着急地向目标走去。然后终于<br>到了这个目的地，但是你却发现，抑或是有人告诉你，前方有更漂亮的风景，你如果到达那里，人生会有<br>更精彩的不同……如此这般循环几个光景，你的人生就这样匆匆而去而鲜有发自内心的愉悦。<br>　　春节期间看到了一个讽刺的帖子，其中最主要的内容是:”真正好的办法是巧妙引导，控制节奏，让<br>臣民们始终保持一种奋斗的状态。20出头，头十年，让他们去为房子，车子，娶妻生子忙，第二个十年，<br>让他们为房贷，车贷，子女教育经费去忙，等到了第三个十年，就得为老来医保，儿女成人等做准备而继<br>续忙。如此一来，人生最黄金的三十年不经意间弹指而过。在臣民们为自己所谓生活而忙碌时，就不太会<br>有人能静下心来质疑苏丹统治的正当性，合法性等等命题。”<br>　　这其中，有多少人不是我们自己给自己定义的成功标准，或者在外在的氛围和期望的影响下，进行自我<br>审查和个性阉割，从而成为“成功”这条路上的一个急匆匆的行者的呢？</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　春节假期转眼就过去了，感觉是过得最快的一个春节。马上又面临新的挑战，正处在一个学习<br>和工作的过渡期，莫名的烦心事和压力随之而来。开学时间很早，之前所有相聚的年轻人一股脑儿<br>全离开了，为了明年的春节聚首又回到城市奋斗，看得让人心慌，想到未来我在哪里，是否也像他]]>
    </summary>
    
      <category term="diary" scheme="http://linghutf.gitcafe.io/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[进展汇总,新阶段计划]]></title>
    <link href="http://linghutf.gitcafe.io/2016/02/22/springsemister/"/>
    <id>http://linghutf.gitcafe.io/2016/02/22/springsemister/</id>
    <published>2016-02-22T08:30:36.000Z</published>
    <updated>2016-02-22T13:01:49.000Z</updated>
    <content type="html"><![CDATA[<h1 id="u5E74_u524D_u7684_u81EA_u6211_u5B89_u6170"><a href="#u5E74_u524D_u7684_u81EA_u6211_u5B89_u6170" class="headerlink" title="年前的自我安慰"></a>年前的自我安慰</h1><p>新年之前，给自己画了很多美好的期许，如同中学生涯的放假期间，带回去很多课本和试卷，<br>结果又原封不动地带回学校一样，这些定下的计划鲜有完成。大概也就是没有手生而已。我把<br>这种现象叫做心理上的自我安慰。</p>
<h1 id="u7B2C_u4E00_u6B21_u5F00_u4F1A_u4E4B_u524D_u7684_u8865_u6551"><a href="#u7B2C_u4E00_u6B21_u5F00_u4F1A_u4E4B_u524D_u7684_u8865_u6551" class="headerlink" title="第一次开会之前的补救"></a>第一次开会之前的补救</h1><p>半个月过去了，我又回到那个朝九晚十的生活轨道，赶紧在进度报告之前，完成一些工作。经过<br>几天的不断写代码和测试，也算是完成了以下任务:</p>
<ol>
<li>实现了文件按数据块的对称加、解密</li>
<li>理解了一部分冗余分散加密的原理<br>再加上一些研究过程中的速记note,应该可以进行下一步的工作了。</li>
</ol>
<h1 id="u4E0B_u4E00_u6B65_u7684_u5DE5_u4F5C"><a href="#u4E0B_u4E00_u6B65_u7684_u5DE5_u4F5C" class="headerlink" title="下一步的工作"></a>下一步的工作</h1><p>这大概是我学习生涯以来，如此有总结性和计划性的时刻，办公的电脑桌面文件夹里，都是各种各<br>样的todo-list和note。<br>下一步主要就是<strong>实现caont-rs冗余加/解码</strong>了，因此需要了解迦罗瓦运算，详细地阅读原作者的<br>实现了。<br>过渡期就是如此麻烦，还需要留心即将到来的暑期实习招聘，一边需要做准备了。毕竟不想再经历本科<br>毕业时候的迷茫和毫无准备的仓促。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u5E74_u524D_u7684_u81EA_u6211_u5B89_u6170"><a href="#u5E74_u524D_u7684_u81EA_u6211_u5B89_u6170" class="headerlink" title="年前的自我安慰"><]]>
    </summary>
    
      <category term="program schedule" scheme="http://linghutf.gitcafe.io/tags/program-schedule/"/>
    
      <category term="todo" scheme="http://linghutf.gitcafe.io/tags/todo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[写在放假之前]]></title>
    <link href="http://linghutf.gitcafe.io/2016/01/29/winter-vacation/"/>
    <id>http://linghutf.gitcafe.io/2016/01/29/winter-vacation/</id>
    <published>2016-01-29T06:28:09.000Z</published>
    <updated>2016-01-29T14:41:52.000Z</updated>
    <content type="html"><![CDATA[<h1 id="u5306_u5FD9_u4E0E_u65E0_u6240_u9002_u4ECE_u4E4B_u95F4"><a href="#u5306_u5FD9_u4E0E_u65E0_u6240_u9002_u4ECE_u4E4B_u95F4" class="headerlink" title="匆忙与无所适从之间"></a>匆忙与无所适从之间</h1><p>　快到猴年春节了，这一年过得很累，发生了太多的事，压力也大了起来，未来的工作，现在<br>的生活…都交织在我的脑海里。很想回去舒服地躺在床上看看书，或者就是发一下午呆。可<br>惜时间不等人，两周里还有很多要完成的事。<br>　不过，能过第一个想回家吃妈妈做的菜的春节，我的心情还是有些愉快迫切的、
　</p>
<h1 id="u5047_u671F_u7684_u9050_u60F3"><a href="#u5047_u671F_u7684_u9050_u60F3" class="headerlink" title="假期的遐想"></a>假期的遐想</h1><p>　最近的两周老板也没怎么来，我手头的事情也比较棘手，有些像刺猬无从下嘴的感觉。检讨<br>一下工作就是零星做了些面试算法题，leetcode英文题对于目前浮躁的我来说有些难，DP、背包<br>也没有看，回家需要复习一下算法了。文件系统，加密模块,也需要做个雏形出来。<br>　很想潇潇洒洒地在家里四处游荡，和朋友去爬山，然后静静坐在山峰最高处，静静地注视着芸<br>芸众生、人间烟火，做着无边无际的梦。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u5306_u5FD9_u4E0E_u65E0_u6240_u9002_u4ECE_u4E4B_u95F4"><a href="#u5306_u5FD9_u4E0E_u65E0_u6240_u9002_u4ECE_u4E4B_u95F4" class="heade]]>
    </summary>
    
      <category term="diary" scheme="http://linghutf.gitcafe.io/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[leetcode-319的算法思考]]></title>
    <link href="http://linghutf.gitcafe.io/2016/01/21/leetcode319/"/>
    <id>http://linghutf.gitcafe.io/2016/01/21/leetcode319/</id>
    <published>2016-01-21T06:49:47.000Z</published>
    <updated>2016-04-11T07:39:09.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u9898_u76EE"><a href="#u9898_u76EE" class="headerlink" title="题目"></a>题目</h2><p>There are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it’s off or turning off if it’s on). For the nth round, you only toggle the last bulb. Find how many bulbs are on after n rounds.</p>
<p>Example:</p>
<p>Given n = 3. </p>
<p>At first, the three bulbs are [off, off, off].<br>After first round, the three bulbs are [on, on, on].<br>After second round, the three bulbs are [on, off, on].<br>After third round, the three bulbs are [on, off, off]. </p>
<p>So you should return 1, because there is only one bulb is on.</p>
<h3 id="u9898_u76EE_u542B_u4E49"><a href="#u9898_u76EE_u542B_u4E49" class="headerlink" title="题目含义"></a>题目含义</h3><p>就是说给n个开关分别对应控制这n个灯泡的亮灭，步骤如下:</p>
<ul>
<li>开始时开关都是关的，为方便叙述，位置从1开始</li>
<li>step=1,将所有位置的开关打开</li>
<li>step=2,将所有位置为2的倍数的开关转换状态</li>
<li>…</li>
<li>step=n,转换完开关后,统计还有多少灯泡开者</li>
</ul>
<hr>
<h1 id="u89E3_u6CD5"><a href="#u89E3_u6CD5" class="headerlink" title="解法"></a>解法</h1><h2 id="1-_u76F4_u89C2_u89E3_u6CD5"><a href="#1-_u76F4_u89C2_u89E3_u6CD5" class="headerlink" title="1.直观解法"></a>1.直观解法</h2><h3 id="u601D_u8DEF"><a href="#u601D_u8DEF" class="headerlink" title="思路"></a>思路</h3><p>分析完题目后,首先想到的就是把开关这些控制流程自己模拟<br>一遍，用布尔数组模拟开关，最后统计为true的开关数就可以<br>了。</p>
<p>那就开始写吧，leetcode支持c/c++，感觉够了，至于能不能<br>用STL库还不清楚，自己动手写一些常用数据结构，虽说性能有<br>损失，但是为了AC,也只能自己注意性能了，尽量不要手动分配<br>大的数组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bulbswitcher</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//c99支持的关键字_Bool,ansi不支持,leetcode测试通过</span></span><br><span class="line">    <span class="keyword">_Bool</span> *p=(<span class="keyword">_Bool</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">_Bool</span>)*n);</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//全为false,避免求反时未定义</span></span><br><span class="line">    <span class="built_in">memset</span>(p,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">_Bool</span>)*n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;++j)&#123;           <span class="comment">//step 1-&gt;n</span></span><br><span class="line">        <span class="keyword">for</span>(i=j;i&lt;n;i+=j+<span class="number">1</span>)&#123;    <span class="comment">//对应的开关,每次跳跃的间隔j+1</span></span><br><span class="line">            *(p+i)=!(*(p+i));   <span class="comment">//不知道编译器是否会优化，所以采用这种直接寻址方式</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//统计为true的开关,如果有c++的accumulate更好</span></span><br><span class="line">    sum(p,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上传到leetcode jude,不一会儿出现了Limit except，发现它的测试数是10000000,<br>总用时1+s,这么大数字居然超时了.我自己在线下测试的结果：</p>
<ul>
<li><p>普通编译:<br><img src="http://7xr8se.com1.z0.glb.clouddn.com/leetcode319-1.png" alt="leetcode-1"></p>
</li>
<li><p>开启-O2 优化<br><img src="http://7xr8se.com1.z0.glb.clouddn.com/leetcode319-2.png" alt="leetcode-2"></p>
</li>
</ul>
<p>可以发现这种算法复杂度O(n^2),数字一大性能就不行了。普通编译结果也是超过1s,看来leetcode没有做优化,并且超时时间设置1s,<br>如此只能再想其他解法.</p>
<hr>
<h2 id="2-_u8FDB_u9636_u65B9_u6848"><a href="#2-_u8FDB_u9636_u65B9_u6848" class="headerlink" title="2.进阶方案"></a>2.进阶方案</h2><p>总觉得这样转换的状像是符合某种数学规律，也许是常年的理工教育培养了这种直觉，<br>我就试一试究竟有没有规律,基于现有代码很好改动。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> max)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;max;++i)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%3d:%3d\n"</span>,i,bulbswitcher(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>打印结果:<br><img src="http://7xr8se.com1.z0.glb.clouddn.com/leetcode319-3.png" alt="leetcode-3"></p>
<p>居然有这么多一样的，看起来像台阶一样，必须满足某种条件才能增加一级.<br>那我再改进一下试探方法,为了一查究竟这么多相同的数字有什么关系，以及开关<br>数n和最后结果的关系，采用哈希表去做，c没有，其实开个大数组也行，我这里用<br>的是Go。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> test(n <span class="typename">int</span>)&#123;</span><br><span class="line">    m:=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="typename">int</span>]<span class="typename">int</span>,n)</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++&#123;</span><br><span class="line">        m[bulbswitcher(i)]++</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//无序表，对key排序    </span></span><br><span class="line">    sort.SortInts(map_keys)</span><br><span class="line">    <span class="keyword">for</span> _,k:=<span class="keyword">range</span> map_keys&#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%3d:%3d\n"</span>,k,m[k])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果:<br><img src="http://7xr8se.com1.z0.glb.clouddn.com/leetcode319-4.png" alt="leetcode-4"></p>
<p>果然有关系!原来最后的结果对应的原始开关数n是一个奇数等差数列:<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">第i级,<span class="keyword">ret</span>表示<span class="keyword">n</span>在这一级内，则最终的结果</span><br><span class="line">cnt表示有多少个<span class="keyword">n</span>是对应<span class="keyword">ret</span>这个结果的，也就是<span class="keyword">n</span>的范围</span><br><span class="line">关系如下:</span><br><span class="line">       2*<span class="keyword">ret</span>+1 = cnt </span><br><span class="line">=&gt;     <span class="keyword">ret</span> = (cnt-1)/2</span><br></pre></td></tr></table></figure></p>
<p>现在我们只要求出这个范围cnt就行了。由于k对应的最后的结果，而v对应n,表明我们需要判断这个n落在哪一级内，<br>也就是将v加起来，直到加到第i级超过n的值，那么n就是在这一级内。<br>基于这种思想有代码:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">magic</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i,cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">3</span>;cnt&lt;n;i+=<span class="number">2</span>)&#123; <span class="comment">//第i级所包含的原始开关数范围,cnt统计n之前的数量</span></span><br><span class="line">        cnt+=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (i-<span class="number">3</span>)&gt;&gt;<span class="number">1</span>;<span class="comment">//因为数列没有cnt=1对应的ret</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>改进之后算法复杂度为O(n/2)=&gt;O(n)，现在上传改进的代码,这次通过了，耗时0s,但是在分布图里，<br>居然只打败了同样用C的6.83%,看来很多人结果比我好啊，也不知道<br>它的测试数字是不是都是一样的。</p>
<p>看一下能不能继续改进。对了，奇数等差数列不是有求和公式吗?我们知道n，直接求它在那一级的范围<br>内，不就是ret的值么?避免了一个个去加然后判断,这就是最终版本的方法。</p>
<h2 id="3-_u6700_u7EC8_u89E3_u6CD5"><a href="#3-_u6700_u7EC8_u89E3_u6CD5" class="headerlink" title="3.最终解法"></a>3.最终解法</h2><p>因为奇数2n-1的求和公式:<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">对于上面的关系有:</span><br><span class="line"></span><br><span class="line">         <span class="keyword">sum</span> = (2*<span class="keyword">ret</span>+1+3)*<span class="keyword">ret</span>/2</span><br><span class="line">     =&gt;      =  <span class="keyword">ret</span>*<span class="keyword">ret</span> + 2*<span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line">所以反推有:     </span><br><span class="line">     -&gt;    <span class="keyword">n</span> &lt;= <span class="keyword">ret</span>*<span class="keyword">ret</span></span><br><span class="line">     =&gt;   <span class="keyword">ret</span> = <span class="literal">sqrt</span>(<span class="keyword">n</span>) 向下取整</span><br></pre></td></tr></table></figure></p>
<p>这种解法C函数表示就是<code>floor(sqrt(n))</code><br>所以改进的代码:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">final_magic</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">floor</span>(<span class="built_in">sqrt</span>(n));<span class="comment">//隐式转型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样简单多了。然后上传leetcode测试结果,35个测试全部通过，<br>耗时0ms，居然还是打败6.88%,郁闷</p>
<h2 id="4-_u4E09_u79CD_u89E3_u6CD5_u7684_u5355_u5143_u3001_u6027_u80FD_u6D4B_u8BD5"><a href="#4-_u4E09_u79CD_u89E3_u6CD5_u7684_u5355_u5143_u3001_u6027_u80FD_u6D4B_u8BD5" class="headerlink" title="4.三种解法的单元、性能测试"></a>4.三种解法的单元、性能测试</h2><p>为了测试的方便，我将代码改写成go，然后使用自带test，之前2方案<br>比较快，所以以它为基准测试其他2种正确性。开始的时候都是手写的测试<br>case,用map去对比,本想设置测试上限10000000，但是超过了10分钟，出<br>现了panic，10万以上第一种方法就很慢了。<br>测试代码部分:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>(</span><br><span class="line">    MAX = <span class="number">10000</span>   <span class="comment">//测试范围</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//通用测试方法，传入测试函数参数</span></span><br><span class="line"><span class="keyword">func</span> test(t *testing.T,Func <span class="keyword">func</span>(<span class="typename">int</span>) <span class="typename">int</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;=MAX;i++&#123;</span><br><span class="line">        <span class="keyword">if</span> Func(i)!=Magic(i)&#123;</span><br><span class="line">            <span class="comment">//结果出错</span></span><br><span class="line">            t.Errorf(<span class="string">"%3d:%3d calc failed."</span>,i,Func(i))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">TestCommon(t)&#123;</span><br><span class="line">    test(t,Common)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TestFinalMagic(t)</span><br></pre></td></tr></table></figure></p>
<p>性能测试，代码类似:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通用性能测试方法</span></span><br><span class="line"><span class="keyword">func</span> bench(b *testing.B,Func <span class="keyword">func</span>(<span class="typename">int</span>) <span class="typename">int</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;=MAX;i++&#123;</span><br><span class="line">        Func(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BenchmarkCommon(b)</span><br><span class="line">BenchmarkMagic(b)</span><br><span class="line">BenchmarFinalkMagic(b)</span><br></pre></td></tr></table></figure></p>
<p>测试结果:<br><img src="http://7xr8se.com1.z0.glb.clouddn.com/leetcode319-5.png" alt="leetcode-5"></p>
<hr>
<h1 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h1><p>第一种最符合程序员解决问题的思维，也很容易理解。后面的方法已经脱离了问题，变成了纯粹的数学问题<br>无奈第一种性能要差得多。这大概就是提醒我们，抽象生活问题成数学问题，然后去解决它吧。很惭愧，我<br>没有通过分析问题去提炼其中的数学规律，而是凭感觉试出来的，<br>最后，学到的是go中的函数参数了，顺便复习了C语言的一些内容。</p>
<h1 id="u540E_u8BB0"><a href="#u540E_u8BB0" class="headerlink" title="后记"></a>后记</h1><ul>
<li>未改进的版本相比改进版本来说，主要的耗时操作是两重循环，一个是O(N^2),一个是O(1);因此只有在n比较小<br>时，下文针对未改进版本优化才有价值</li>
<li>对于这种状态转换问题，可以使用bitset解决，由于STL对位图的优化，每个状态位只占1个bit,比bool变量都<br>快，而且调式更为方便，效率也比数组高很多。</li>
<li>针对每个数字，能被整除的相应位置反转状态，最后只需要统计其中为1的数量即可</li>
<li>n值小的时候，性能比直接找出规律的方案差不了多少，主要的耗时操作是两重循环，所以这种方案也只有n较小<br>才可行，题目的目的是让我们找出规律，使用O(1)的算法。</li>
<li>最后，代码如下:<script src="https://gist.github.com/linghutf/4a0ab262600edda6f944b3eb95569ee9.js?file=bulbswitch.cc"></script></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u9898_u76EE"><a href="#u9898_u76EE" class="headerlink" title="题目"></a>题目</h2><p>There are n bulbs that are initially off. You first ]]>
    </summary>
    
      <category term="algorithm" scheme="http://linghutf.gitcafe.io/tags/algorithm/"/>
    
      <category term="leetcode" scheme="http://linghutf.gitcafe.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2016年第一场雪想到的]]></title>
    <link href="http://linghutf.gitcafe.io/2016/01/21/firstsnow/"/>
    <id>http://linghutf.gitcafe.io/2016/01/21/firstsnow/</id>
    <published>2016-01-20T18:08:28.000Z</published>
    <updated>2016-01-21T15:03:17.000Z</updated>
    <content type="html"><![CDATA[<p>早上一如既往的起床洗漱然后出门，走到楼道口才发现今天居然下雪了，</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>早上一如既往的起床洗漱然后出门，走到楼道口才发现今天居然下雪了，</p>
]]>
    </summary>
    
      <category term="diary" scheme="http://linghutf.gitcafe.io/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[图片服务器的Nodejs和Go版本性能测试]]></title>
    <link href="http://linghutf.gitcafe.io/2016/01/11/golangserv/"/>
    <id>http://linghutf.gitcafe.io/2016/01/11/golangserv/</id>
    <published>2016-01-11T04:12:08.000Z</published>
    <updated>2016-01-12T07:57:30.000Z</updated>
    <content type="html"><![CDATA[<h1 id="u5173_u4E8E_u4E0A_u4E00_u7248_u672C"><a href="#u5173_u4E8E_u4E0A_u4E00_u7248_u672C" class="headerlink" title="关于上一版本"></a>关于上一版本</h1><p>　　昨天完成了nodejs版本的图片服务器<a href="http://linghutf.gitcafe.io/2016/01/10/staticfileserv/">staticserv</a><br>之后，当时没有对请求的类型做判断，这只是我自己使用，如果是做成通用模块，需要考虑防范不合适的请求。之前，<br>首先考虑的是Go版本的服务器，只不过自己没有弄清<strong>go的资源地址都是相对于项目的GOPATH的地址</strong>，还是使用老方法<br><code>\a\b\c.txt</code>去读取文件，结果都无法读到文件，所以写了nodejs版本。今天学习了<code>path/filepath</code>模块之后，终于掌握<br>了正确写法。比如要读取”./a/b.txt”,需要这么写:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">absPath:_:=filepath.Abs(<span class="string">"./a/b.txt"</span>)</span><br><span class="line">bytes,err:=ioutil.ReadFile(absPath)</span><br></pre></td></tr></table></figure></p>
<h1 id="Go_u7248_u672C_u7684_u4E3B_u8981_u529F_u80FD"><a href="#Go_u7248_u672C_u7684_u4E3B_u8981_u529F_u80FD" class="headerlink" title="Go版本的主要功能"></a>Go版本的主要功能</h1><ol>
<li>自定义资源文件位置<br>主要是通过<code>flag</code>模块解析src参数来实现，比如<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.<span class="regexp">/serv -src /</span>tmp</span><br><span class="line">请求<span class="string">URL:</span></span><br><span class="line"><span class="string">http:</span><span class="comment">//xxx/123.jpg</span></span><br><span class="line">最终服务器查找的文件地址:</span><br><span class="line"><span class="regexp">/tmp/</span><span class="number">123.</span>jpg</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>测试中对于”//“这种错误也能兼容，因为它使用的是Join转化路径，而不是拼接字符串。<br>关键代码如下:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">relativePath := req.URL.Path</span><br><span class="line">filename, err := filepath.Abs(filepath.Join(*curDir, relativePath))</span><br></pre></td></tr></table></figure></p>
<ol>
<li>判断请求类型<br>这部分主要有忽略”favicon.ico”请求、判断路径是否正确和文件是否存在<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//忽略favicon请求:</span></span><br><span class="line"><span class="keyword">if</span> relativePath == <span class="string">"/favicon.ico"</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>路径是否正确直接判断上文中的err就好了，这里就不表述。实验时发现请求的是目录，服务<br>器立马输出错误，然后退出了。这怎么行，一点都不健壮，所以要判断是不是文件:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fileinfo, e := os.Stat(filename)</span><br><span class="line"><span class="comment">//文件不存在</span></span><br><span class="line"><span class="keyword">if</span> os.IsNotExist(e) &#123;</span><br><span class="line">	log.Println(filename, <span class="string">" is not exists."</span>)</span><br><span class="line">	res.WriteHeader(<span class="number">404</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不是文件，返回500错误</span></span><br><span class="line"><span class="keyword">if</span> fileinfo.IsDir() &#123;</span><br><span class="line">	res.WriteHeader(<span class="number">500</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>判断文件类型并读取、发送文据<br>判断文件类型主要是为了响应时的<code>content-type</code>,对于不是图片的请求，直接返回了<code>text/plain</code>:<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">extname := filepath.Ext(reqfile)</span><br><span class="line"><span class="keyword">switch</span> extname &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">".jpg"</span>, <span class="string">".jpeg"</span>, <span class="string">".jpe"</span>, <span class="string">".jfif"</span>:</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"image/jpeg"</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">".png"</span>:</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"image/png"</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">".ico"</span>:</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"image/x-icon"</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">".gif"</span>:</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"image/gif"</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">".tif"</span>, <span class="string">".tiff"</span>:</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"image/jiff"</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"text/plain"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>发送数据就比较简单了，为了不在传递参数时拷贝，我用了拷贝指针的办法:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data []<span class="typename">byte</span></span><br><span class="line"><span class="comment">//读取文件</span></span><br><span class="line">ReadFileFromPath(&amp;data, filename)</span><br><span class="line">res.WriteHeader(<span class="number">200</span>)</span><br><span class="line">res.Write(data)</span><br></pre></td></tr></table></figure></p>
<h1 id="u4E0E_u4E0A_u4E00_u7248_u672C_u7684_u6027_u80FD_u6D4B_u8BD5_u5BF9_u6BD4"><a href="#u4E0E_u4E0A_u4E00_u7248_u672C_u7684_u6027_u80FD_u6D4B_u8BD5_u5BF9_u6BD4" class="headerlink" title="与上一版本的性能测试对比"></a>与上一版本的性能测试对比</h1><p>这里主要用到了apache的ab工具，以及开源软件webbench。<br>两者都在同一环境下，均没有做优化。</p>
<ol>
<li>ab测试,并发请求200，总请求数4000:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ab -c <span class="number">200</span> -n <span class="number">4000</span> http:<span class="comment">//localhost:8080/fact10000.png</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>测试结果如下:</p>
<p>go 版本:<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Document Path:          /img/fact10000.png</span><br><span class="line">Document Length:        <span class="number">27488</span> <span class="keyword">bytes</span></span><br><span class="line"></span><br><span class="line">Concurrency Level:      <span class="number">200</span></span><br><span class="line">Time taken <span class="keyword">for</span> tests:   <span class="number">2.493</span> <span class="built_in">seconds</span></span><br><span class="line">Complete requests:      <span class="number">4000</span></span><br><span class="line">Failed requests:        <span class="number">0</span></span><br><span class="line">Total transferred:      <span class="number">110276000</span> <span class="keyword">bytes</span></span><br><span class="line">HTML transferred:       <span class="number">109952000</span> <span class="keyword">bytes</span></span><br><span class="line">Requests per <span class="keyword">second</span>:    <span class="number">1604.80</span> [<span class="comment">#/sec] (mean)</span></span><br><span class="line">Time per request:       <span class="number">124.626</span> [ms] (mean)</span><br><span class="line">Time per request:       <span class="number">0.623</span> [ms] (mean, across all concurrent requests)</span><br><span class="line">Transfer rate:          <span class="number">43205.78</span> [Kbytes/<span class="built_in">sec</span>] received <span class="comment"> //网络传输速度，排除网路问题</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*网络上消耗的时间的分解*/</span></span><br><span class="line">Connection Times (ms)</span><br><span class="line">              <span class="built_in">min</span>  mean[+/-sd] <span class="built_in">median</span>   <span class="built_in">max</span></span><br><span class="line">Connect:        <span class="number">0</span>    <span class="number">4</span>  <span class="number">39.6</span>      <span class="number">0</span>    <span class="number">1003</span></span><br><span class="line">Processing:     <span class="number">3</span>  <span class="number">117</span> <span class="number">143.3</span>     <span class="number">56</span>    <span class="number">1184</span></span><br><span class="line">Waiting:        <span class="number">2</span>   <span class="number">65</span>  <span class="number">41.9</span>     <span class="number">50</span>     <span class="number">173</span></span><br><span class="line">Total:          <span class="number">4</span>  <span class="number">121</span> <span class="number">147.3</span>     <span class="number">57</span>    <span class="number">1184</span></span><br><span class="line"></span><br><span class="line">*下面的内容为整个场景中所有请求的响应情况。在场景中每个请求都有一个响应时间，</span><br><span class="line">其中 <span class="number">50</span>％ 的用户响应时间小于 <span class="number">57</span> 毫秒，<span class="number">66</span> ％ 的用户响应时间小于 <span class="number">100</span> 毫秒，</span><br><span class="line">最大的响应时间小于 <span class="number">1184</span> 毫秒*/</span><br><span class="line"></span><br><span class="line">Percentage <span class="operator">of</span> <span class="operator">the</span> requests served <span class="operator">within</span> <span class="operator">a</span> certain <span class="built_in">time</span> (ms)</span><br><span class="line">  <span class="number">50</span>%     <span class="number">57</span></span><br><span class="line">  <span class="number">66</span>%    <span class="number">109</span></span><br><span class="line">  <span class="number">75</span>%    <span class="number">150</span></span><br><span class="line">  <span class="number">80</span>%    <span class="number">157</span></span><br><span class="line">  <span class="number">90</span>%    <span class="number">290</span></span><br><span class="line">  <span class="number">95</span>%    <span class="number">406</span></span><br><span class="line">  <span class="number">98</span>%    <span class="number">583</span></span><br><span class="line">  <span class="number">99</span>%    <span class="number">739</span></span><br><span class="line"> <span class="number">100</span>%   <span class="number">1184</span> (longest request)</span><br></pre></td></tr></table></figure></p>
<p>nodejs版本:<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Concurrency Level:      <span class="number">200</span></span><br><span class="line">Time taken <span class="keyword">for</span> tests:   <span class="number">3.019</span> <span class="built_in">seconds</span></span><br><span class="line">Complete requests:      <span class="number">4000</span></span><br><span class="line">Failed requests:        <span class="number">0</span></span><br><span class="line">Total transferred:      <span class="number">110352000</span> <span class="keyword">bytes</span></span><br><span class="line">HTML transferred:       <span class="number">109952000</span> <span class="keyword">bytes</span></span><br><span class="line">Requests per <span class="keyword">second</span>:    <span class="number">1325.07</span> [<span class="comment">#/sec] (mean)</span></span><br><span class="line">Time per request:       <span class="number">150.935</span> [ms] (mean)</span><br><span class="line">Time per request:       <span class="number">0.755</span> [ms] (mean, across all concurrent requests)</span><br><span class="line">Transfer rate:          <span class="number">35699.34</span> [Kbytes/<span class="built_in">sec</span>] received</span><br><span class="line"></span><br><span class="line">Connection Times (ms)</span><br><span class="line">              <span class="built_in">min</span>  mean[+/-sd] <span class="built_in">median</span>   <span class="built_in">max</span></span><br><span class="line">Connect:        <span class="number">0</span>   <span class="number">24</span> <span class="number">150.8</span>      <span class="number">0</span>    <span class="number">1003</span></span><br><span class="line">Processing:    <span class="number">67</span>  <span class="number">119</span>  <span class="number">50.4</span>    <span class="number">103</span>     <span class="number">420</span></span><br><span class="line">Waiting:       <span class="number">67</span>  <span class="number">118</span>  <span class="number">50.3</span>    <span class="number">103</span>     <span class="number">420</span></span><br><span class="line">Total:         <span class="number">71</span>  <span class="number">143</span> <span class="number">156.3</span>    <span class="number">105</span>    <span class="number">1116</span></span><br><span class="line"></span><br><span class="line">Percentage <span class="operator">of</span> <span class="operator">the</span> requests served <span class="operator">within</span> <span class="operator">a</span> certain <span class="built_in">time</span> (ms)</span><br><span class="line">  <span class="number">50</span>%    <span class="number">105</span></span><br><span class="line">  <span class="number">66</span>%    <span class="number">125</span></span><br><span class="line">  <span class="number">75</span>%    <span class="number">141</span></span><br><span class="line">  <span class="number">80</span>%    <span class="number">145</span></span><br><span class="line">  <span class="number">90</span>%    <span class="number">160</span></span><br><span class="line">  <span class="number">95</span>%    <span class="number">303</span></span><br><span class="line">  <span class="number">98</span>%   <span class="number">1093</span></span><br><span class="line">  <span class="number">99</span>%   <span class="number">1099</span></span><br><span class="line"> <span class="number">100</span>%   <span class="number">1116</span> (longest request)</span><br></pre></td></tr></table></figure></p>
<p>二者情况是差不多的，go略微好于nodejs。</p>
<ol>
<li>连续3次请求测试平均值,选取用户最关心的三项参数<br>go:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Requests per second:    <span class="number">1604.80</span> [<span class="preprocessor">#/sec] (mean)    <span class="comment">//吞吐率</span></span></span><br><span class="line">Time per request:       <span class="number">124.626</span> [ms] (mean)      <span class="comment">//用户平均请求等待时间</span></span><br><span class="line">Time per request:       <span class="number">0.623</span> [ms] (mean, across all concurrent requests) <span class="comment">//服务器平均请求等待时间</span></span><br><span class="line"></span><br><span class="line">Requests per second:    <span class="number">1627.66</span> [<span class="preprocessor">#/sec] (mean)</span></span><br><span class="line">Time per request:       <span class="number">122.876</span> [ms] (mean)</span><br><span class="line">Time per request:       <span class="number">0.614</span> [ms] (mean, across all concurrent requests)</span><br><span class="line"></span><br><span class="line">Requests per second:    <span class="number">1747.35</span> [<span class="preprocessor">#/sec] (mean)</span></span><br><span class="line">Time per request:       <span class="number">114.459</span> [ms] (mean)</span><br><span class="line">Time per request:       <span class="number">0.572</span> [ms] (mean, across all concurrent requests)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>nodejs:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">Requests</span> <span class="tag">per</span> <span class="tag">second</span>:    1325<span class="class">.07</span> <span class="attr_selector">[#/sec]</span> (<span class="tag">mean</span>)      </span><br><span class="line"><span class="tag">Time</span> <span class="tag">per</span> <span class="tag">request</span>:       150<span class="class">.935</span> <span class="attr_selector">[ms]</span> (<span class="tag">mean</span>)         </span><br><span class="line"><span class="tag">Time</span> <span class="tag">per</span> <span class="tag">request</span>:       0<span class="class">.755</span> <span class="attr_selector">[ms]</span> (<span class="tag">mean</span>, <span class="tag">across</span> <span class="tag">all</span> <span class="tag">concurrent</span> <span class="tag">requests</span>)  </span><br><span class="line"></span><br><span class="line"><span class="tag">Requests</span> <span class="tag">per</span> <span class="tag">second</span>:    1156<span class="class">.69</span> <span class="attr_selector">[#/sec]</span> (<span class="tag">mean</span>)</span><br><span class="line"><span class="tag">Time</span> <span class="tag">per</span> <span class="tag">request</span>:       172<span class="class">.908</span> <span class="attr_selector">[ms]</span> (<span class="tag">mean</span>)</span><br><span class="line"><span class="tag">Time</span> <span class="tag">per</span> <span class="tag">request</span>:       0<span class="class">.865</span> <span class="attr_selector">[ms]</span> (<span class="tag">mean</span>, <span class="tag">across</span> <span class="tag">all</span> <span class="tag">concurrent</span> <span class="tag">requests</span>)</span><br><span class="line"></span><br><span class="line"><span class="tag">Requests</span> <span class="tag">per</span> <span class="tag">second</span>:    1231<span class="class">.65</span> <span class="attr_selector">[#/sec]</span> (<span class="tag">mean</span>)</span><br><span class="line"><span class="tag">Time</span> <span class="tag">per</span> <span class="tag">request</span>:       162<span class="class">.383</span> <span class="attr_selector">[ms]</span> (<span class="tag">mean</span>)</span><br><span class="line"><span class="tag">Time</span> <span class="tag">per</span> <span class="tag">request</span>:       0<span class="class">.812</span> <span class="attr_selector">[ms]</span> (<span class="tag">mean</span>, <span class="tag">across</span> <span class="tag">all</span> <span class="tag">concurrent</span> <span class="tag">requests</span>)</span><br></pre></td></tr></table></figure></p>
<p>可以看出二者在吞吐率上,Go好于nodejs,平均等待时间上二者相差无几。</p>
<ol>
<li>webbench 压力测试<br>压力测试30秒内，并发请求数200,连续测试3次<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webbench -t <span class="number">30</span> -c <span class="number">200</span> http:<span class="comment">//127.0.0.1:8080/img/fact10000.png</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>go的表现:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Speed=<span class="number">111574</span> pages/min, <span class="number">51317124</span> bytes/sec. <span class="comment">//速度，111574页/每分钟，51317124字节/秒</span></span><br><span class="line">Speed=<span class="number">100538</span> pages/min, <span class="number">46228920</span> bytes/sec.</span><br><span class="line">Speed=<span class="number">103186</span> pages/min, <span class="number">47440784</span> bytes/sec.</span><br><span class="line"></span><br><span class="line">资源占用:</span><br><span class="line">VIRT    RES     SHR     CPU   MEM   TIME</span><br><span class="line"><span class="number">364756</span>  <span class="number">26252</span>   <span class="number">4336</span> S  <span class="number">61.9</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">15.26</span> serv </span><br><span class="line"><span class="number">364884</span>  <span class="number">25960</span>   <span class="number">4044</span> S  <span class="number">58.7</span>  <span class="number">0.0</span></span><br><span class="line"><span class="number">364884</span>  <span class="number">25960</span>   <span class="number">4044</span> R  <span class="number">57.9</span>  <span class="number">0.0</span></span><br></pre></td></tr></table></figure></p>
<p>nodejs的表现:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Speed=<span class="number">78864</span> pages/min, <span class="number">36259112</span> bytes/sec.</span><br><span class="line">Speed=<span class="number">42868</span> pages/min, <span class="number">19710708</span> bytes/sec.</span><br><span class="line">Speed=<span class="number">36340</span> pages/min, <span class="number">16708262</span> bytes/sec.</span><br><span class="line"></span><br><span class="line">资源占用:</span><br><span class="line">VIRT    RES     SHR     CPU   MEM   TIME</span><br><span class="line"><span class="number">955320</span>  <span class="number">74196</span>  <span class="number">14252</span> R  <span class="number">73.6</span>  <span class="number">0.1</span>   <span class="number">0</span>:<span class="number">10.49</span> node</span><br><span class="line"><span class="number">960768</span>  <span class="number">79408</span>  <span class="number">14252</span> R  <span class="number">33.2</span>  <span class="number">0.1</span></span><br><span class="line"><span class="number">961604</span>  <span class="number">79256</span>  <span class="number">14252</span> R  <span class="number">34.7</span>  <span class="number">0.1</span></span><br></pre></td></tr></table></figure></p>
<p>二者都是0错误,可以看出nodejs在速度和资源占用率都比Go表现的差，<br>速度大概只有go的一半不到，内存占用率却是go的3倍左右，CPU使用率<br>稍好于go。</p>
<h1 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h1><p>   从测试里可以看到，Go的http性能是好于nodejs的，不过对于这么<br>简单的应用，可能无法完全反应Go和nodejs的http性能高低吧，但是go的<br>http的模块我觉得很好用，写代码也是同步方式，不像nodejs我写到逻辑越来<br>越复杂的时候就有点越发要好好学一学异步编程的思想，这种思维转换一时还<br>无法适应，所以我往往选择javascript先完成一部分功能，打开思路后使用Go<br>去实现。<br>　另外今天的收获就是学会了做网络测试了，这对我来说又增长了能力。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u5173_u4E8E_u4E0A_u4E00_u7248_u672C"><a href="#u5173_u4E8E_u4E0A_u4E00_u7248_u672C" class="headerlink" title="关于上一版本"></a>关于上一版本</h1]]>
    </summary>
    
      <category term="ab" scheme="http://linghutf.gitcafe.io/tags/ab/"/>
    
      <category term="go" scheme="http://linghutf.gitcafe.io/tags/go/"/>
    
      <category term="nodejs" scheme="http://linghutf.gitcafe.io/tags/nodejs/"/>
    
      <category term="webbench" scheme="http://linghutf.gitcafe.io/tags/webbench/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[静态文件服务]]></title>
    <link href="http://linghutf.gitcafe.io/2016/01/10/staticfileserv/"/>
    <id>http://linghutf.gitcafe.io/2016/01/10/staticfileserv/</id>
    <published>2016-01-10T05:44:38.000Z</published>
    <updated>2016-01-10T14:50:31.000Z</updated>
    <content type="html"><![CDATA[<h1 id="u4E3A_u4EC0_u4E48_u505A_u9759_u6001_u6587_u4EF6_u670D_u52A1_u5668"><a href="#u4E3A_u4EC0_u4E48_u505A_u9759_u6001_u6587_u4EF6_u670D_u52A1_u5668" class="headerlink" title="为什么做静态文件服务器"></a>为什么做静态文件服务器</h1><p>　　这几天博客搭建起来后，美化和主题也设置得差不多了，就是在写作时，<br>有时候需要插入图片，图片使用的相对地址会在hexo生成博客时失效，总不<br>可能插入一个图片就在它生成后去相应的html里改引用地址吧，再说上传的时<br>候Hexo可能默认不会上传。<br>　　所以这种情况下，就需要一个文件服务器去为我们生成的博客传输图片。</p>
<h1 id="u73B0_u6709_u7684_u89E3_u51B3_u65B9_u6CD5"><a href="#u73B0_u6709_u7684_u89E3_u51B3_u65B9_u6CD5" class="headerlink" title="现有的解决方法"></a>现有的解决方法</h1><h2 id="1-_u4E03_u725B_u670D_u52A1"><a href="#1-_u4E03_u725B_u670D_u52A1" class="headerlink" title="1.七牛服务"></a>1.七牛服务</h2><p>　　七牛的静态文件服务听说性能很高，也是用我最近学习的golang写的。不少<br>人都是推荐这种服务，所以我就去七牛官网看了一下，有免费试用版，每个月<br>请求一万次到十万次，对我来说够用了。想注册的时候有以下两点要求我比较介意:</p>
<ul>
<li>需要填写手机号</li>
<li>个人信息等隐私内容。</li>
</ul>
<p>　　国内的服务很多都把个人信息卖了，导致我总是收到垃圾短信和推销电话，因此现在就奉行<br>能不注册就不注册的态度。另外，我写个博客还要去七牛上上传，两边还得对上号，再说自己的<br>需求就是插入静态内容，也不复杂，为什么不自己做呢？自己动手，丰衣足食，还可以后续改进。<br>所以有了下面的做法。</p>
<h2 id="2-_u5728_u4E91_u4E0A_u642D_u5EFA_u6587_u4EF6_u670D_u52A1_u5668"><a href="#2-_u5728_u4E91_u4E0A_u642D_u5EFA_u6587_u4EF6_u670D_u52A1_u5668" class="headerlink" title="2.在云上搭建文件服务器"></a>2.在云上搭建文件服务器</h2><p>　　当浏览到包含插入图片的博客时，相当于发起了一次http请求，如果返回的是200,那就是说明<br>取到了图片，所以我们文件服务这边就是写一个http服务，监听这些请求，发送图片的数据过去就<br>行了。具体逻辑如下:</p>
<ol>
<li>在md引用地址写上要请求的文件的地址A</li>
<li>服务监听端口，一旦有请求过来，就取request的url中的文件路径</li>
<li>判断该文件是否存在，如果不存在返回404</li>
<li>存在该文件的话，读取文件，response返回二进制数据即可</li>
</ol>
<h1 id="u5177_u4F53_u5B9E_u73B0"><a href="#u5177_u4F53_u5B9E_u73B0" class="headerlink" title="具体实现"></a>具体实现</h1><p>　　本来先写Go版本的，结果测试时，go中读取文件的”ioutil”和”os”模块都不能读取多层目录下的<br>文件内容，为了尽快上线，我用了nodejs,里面的http模块也很好用，异步不需要等待的特点正好适合<br>I/O操作，前期也没有考虑多个请求就开多个操作，或者是否Javascript异步模型不需要这些东西来提<br>高性能。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 访问根目录在当前目录,</span><br><span class="line"> * 例如要访问img下的fact.png,就使用http://[云地址]:8080/img/fact.png</span><br><span class="line"> * </span><br><span class="line"> **/</span></span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> rootPath = <span class="string">"."</span>;</span><br><span class="line">	<span class="comment">//屏蔽favicon请求</span></span><br><span class="line">	<span class="keyword">if</span>(req.url!==<span class="string">'/favicon.ico'</span>)&#123;</span><br><span class="line">		<span class="keyword">var</span> filename = rootPath+req.url;</span><br><span class="line">		<span class="keyword">var</span> img_type = path.extname(req.url).split(<span class="string">'.'</span>)[<span class="number">1</span>];</span><br><span class="line">		<span class="comment">//读取相应的文件</span></span><br><span class="line">		fs.readFile(filename,<span class="string">'binary'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,file</span>)</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(err)&#123;</span><br><span class="line">				res.writeHead(<span class="number">500</span>,&#123;<span class="string">"Content-Type"</span>:<span class="string">"text/plain"</span>&#125;);</span><br><span class="line">				res.write(err+<span class="string">'\n'</span>);</span><br><span class="line">			    <span class="built_in">console</span>.log(<span class="string">'request:'</span>,req.url,<span class="string">'\t\t[Failed].'</span>);</span><br><span class="line">				res.end();</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;<span class="comment">//返回数据</span></span><br><span class="line">				res.writeHead(<span class="number">200</span>,&#123;<span class="string">"Content-Type"</span>:<span class="string">"image/"</span>+img_type&#125;);</span><br><span class="line">				res.write(file,<span class="string">"binary"</span>);</span><br><span class="line">				<span class="built_in">console</span>.log(<span class="string">'request:'</span>,req.url,<span class="string">'\t\t[Ok].'</span>);</span><br><span class="line">				res.end();<span class="comment">//等待发送完成</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;).listen(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure></p>
<p>　　然后将这段代码发在云上运行，并将博客里要插入的图片放在rootPath下，更新<br>博客后，再访问服务端果然出现了request ok的信息，gitcafe和github上的博客在浏<br>览时，也成功加载了图片。说明我的想法是正确的。</p>
<h1 id="u540E_u7EED"><a href="#u540E_u7EED" class="headerlink" title="后续"></a>后续</h1><p>服务器写的还是很简陋的，总的来说有以下需要改进:</p>
<ol>
<li>将服务器地址写到配置文件中，而不是每次都写域名，更新域名更方便。</li>
<li>既没有对请求进行判断，不能防范攻击。</li>
<li>多个人浏览时是否依旧能流畅加载图片没有测试。</li>
<li>javascript的异步模式应该多个请求怎么处理没有弄清。<br>　　<br>所以，接下来针对这几点，可以一边用一边改，这就是未完的工作了。不过好歹可以用了，<br>也不用去注册一个服务，自己又得到了锻炼。说不定发展到最后可以提供多个服务。一个<br>web框架大概也是这样一点一点地加起来的。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u4E3A_u4EC0_u4E48_u505A_u9759_u6001_u6587_u4EF6_u670D_u52A1_u5668"><a href="#u4E3A_u4EC0_u4E48_u505A_u9759_u6001_u6587_u4EF6_u670D_u]]>
    </summary>
    
      <category term="http" scheme="http://linghutf.gitcafe.io/tags/http/"/>
    
      <category term="nodejs" scheme="http://linghutf.gitcafe.io/tags/nodejs/"/>
    
      <category term="program" scheme="http://linghutf.gitcafe.io/tags/program/"/>
    
      <category term="server" scheme="http://linghutf.gitcafe.io/tags/server/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[最近及假期之间的个人计划]]></title>
    <link href="http://linghutf.gitcafe.io/2016/01/10/schedule/"/>
    <id>http://linghutf.gitcafe.io/2016/01/10/schedule/</id>
    <published>2016-01-09T20:52:30.000Z</published>
    <updated>2016-01-11T12:18:35.000Z</updated>
    <content type="html"><![CDATA[<h1 id="u6700_u8FD1_u7684_u72B6_u51B5"><a href="#u6700_u8FD1_u7684_u72B6_u51B5" class="headerlink" title="最近的状况"></a>最近的状况</h1><p>　　学校的报告一个接一个，等一个个忙完想休息一下，结果导师说我之前给他的报告不行，<br>不是要搜集论文，而是要找美国的存储实验室。1个月10到20个，还要有介绍，这就必须<br>要搜到实验室之后仔细看别人的实验室情况，有点大海捞针的意思。每天一来实验室面对<br>这些，春节过后还要找实习，必须要复习一些东西，另外之前的计划工作也需要完成，心态<br>就越发变得急躁了。<br>　　从15年12月初开始就忙碌了起来，当时要考数学和英语，另外还有学院的一个项目，写报告，<br>复习，确定每天的工作计划，感觉事情就像流水线一样过来，必须要确定轻重缓急，看过很多书籍<br>和电影说<strong>把每天的工作列成一个清单，按重要程度分为20%和80%,完成那20%重要的事情。</strong>这样<br>才是有效率，不会忙了一天还不知道忙的什么。当时就觉得这个方案很有必要，开始每天在桌面上<br>写清单了，做完一个标记完成。可是时间一长，桌面图标多得惨不忍睹，也不知道具体一项任务写到<br>哪里去了，还是有点乱糟糟的。所以萌生了统一写博客里，还能不随时携带就可以查阅。</p>
<h1 id="u4E4B_u524D_u7684_u6E05_u5355"><a href="#u4E4B_u524D_u7684_u6E05_u5355" class="headerlink" title="之前的清单"></a>之前的清单</h1><ul>
<li>工程数学                 2015-12-05                        完成(js 统计库一半)</li>
<li>英语口语                 2015-12-17        口语提纲        完成</li>
<li>移动互联网演讲           2015-12-23        sslstrip实验    完成                  </li>
<li>移动互联网安全报告       2016-01-03                        完成</li>
<li>并行处理报告 Latex       2016-01-05        LaTeX模板       完成</li>
<li>cdstore搭建、测试        2015-12-25        docker          完成</li>
</ul>
<h1 id="u672A_u6765_u8981_u505A_u7684_u4E8B_u60C5"><a href="#u672A_u6765_u8981_u505A_u7684_u4E8B_u60C5" class="headerlink" title="未来要做的事情"></a>未来要做的事情</h1><h2 id="1-_u5B66_u4E1A_u65B9_u9762"><a href="#1-_u5B66_u4E1A_u65B9_u9762" class="headerlink" title="1.学业方面"></a>1.学业方面</h2><p>准备:</p>
<ul>
<li>Linux C底层，数据存储书籍，论文</li>
<li>分散加密论文，Hash、前后相关论文</li>
<li>数据去重论文</li>
</ul>
<p>截止日期:2016-01-30 :待定</p>
<ul>
<li>实验室报告，至少15个，数量为先，介绍可以简单一些，只列出<strong>名称、网址、研究方向、研究成果</strong></li>
<li>磁盘分散加密，去重<ul>
<li>C底层数据块控制</li>
<li>hash加密</li>
<li>比对，删除重复，软连接保持一致</li>
</ul>
</li>
<li>Latex学习，考虑写开题报告</li>
</ul>
<h2 id="2-_u5DE5_u4F5C_u76F8_u5173"><a href="#2-_u5DE5_u4F5C_u76F8_u5173" class="headerlink" title="2.工作相关"></a>2.工作相关</h2><p>时间:2016-01-10 ~ 2016-03</p>
<ul>
<li>数据结构复习，链表、优先队列、二叉树、哈希表相关，c/go实现</li>
<li>操作系统，线程相关，了解分布式</li>
<li>网络，http/net相关，TCP/IP介绍,epoll，Ajax异步</li>
<li>数据库，完整操作一遍</li>
<li>相关复习计划参照<a href="https://www.zhihu.com/question/28033201" target="_blank" rel="external">2016工作</a>、<a href="https://www.zhihu.com/question/34574154/answer/74272370" target="_blank" rel="external">后台准备</a></li>
</ul>
<h2 id="3-_u4E1A_u4F59_u953B_u70BC"><a href="#3-_u4E1A_u4F59_u953B_u70BC" class="headerlink" title="3.业余锻炼"></a>3.业余锻炼</h2><p>起始:2016-02-01 ~ 2016-03</p>
<ul>
<li>博客文件服务器，根据请求返回插图</li>
<li>go数据结构与算法</li>
<li>beego博客,ajax前端部分</li>
</ul>
<h1 id="u540E_u8BB0"><a href="#u540E_u8BB0" class="headerlink" title="后记"></a>后记</h1><p>　　先想到这些，就暂时记这么多吧，完成一件会标记一项。按照事情紧迫性一件件地去落实，<br>相信最终必然有收获!</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u6700_u8FD1_u7684_u72B6_u51B5"><a href="#u6700_u8FD1_u7684_u72B6_u51B5" class="headerlink" title="最近的状况"></a>最近的状况</h1><p>　　学校的报告一个接]]>
    </summary>
    
      <category term="program schedule" scheme="http://linghutf.gitcafe.io/tags/program-schedule/"/>
    
      <category term="todo" scheme="http://linghutf.gitcafe.io/tags/todo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hexo静态博客建立指南]]></title>
    <link href="http://linghutf.gitcafe.io/2016/01/09/bloghelp/"/>
    <id>http://linghutf.gitcafe.io/2016/01/09/bloghelp/</id>
    <published>2016-01-09T02:56:27.000Z</published>
    <updated>2016-01-10T07:25:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="u9759_u6001_u535A_u5BA2_u642D_u5EFA"><a href="#u9759_u6001_u535A_u5BA2_u642D_u5EFA" class="headerlink" title="静态博客搭建"></a>静态博客搭建</h1><ul>
<li>主要针对新版hexo(&gt;=3.0),之前的也就是同时发布的修改方法不同</li>
</ul>
<p>根据我这两天搭建的经历，写下详细的帮助教程，总结自己的经验，也是为了避免后来者犯错。<br>注意:<strong>现在hexo都是3.0以上版本，使用方法与之前的2.0版本有所不同，这也是我被坑的地方，需要用新的方法.</strong></p>
<h2 id="1-_u5B89_u88C5Hexo_u7B49_u5DE5_u5177"><a href="#1-_u5B89_u88C5Hexo_u7B49_u5DE5_u5177" class="headerlink" title="1.安装Hexo等工具"></a>1.安装Hexo等工具</h2><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">前提工具:git nodejs <span class="built_in">npm</span> ssh服务</span><br><span class="line"><span class="built_in">npm</span> install hexo hexo-deploy-git -g</span><br></pre></td></tr></table></figure>
<p>我安装在免费的云中，这样换个地方，换台电脑也能有环境编辑上传文件，安装在本地需要额外的步骤。<br>国内免费的有<a href="https://coding.net/" target="_blank" rel="external">代码市场</a>，反正也就一个编辑上传的地方。当然也可以直接使用<br>云的服务建立博客，这种最简单。</p>
<h2 id="2-_u5EFA_u7ACB_u672C_u5730_u955C_u50CF"><a href="#2-_u5EFA_u7ACB_u672C_u5730_u955C_u50CF" class="headerlink" title="2.建立本地镜像"></a>2.建立本地镜像</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir &lt;your <span class="keyword">project</span>&gt;             <span class="comment">//博客项目文件夹</span></span><br><span class="line">cd &lt;your <span class="keyword">project</span>&gt; &amp;&amp; hexo init   <span class="comment">//进入项目，初始化hexo环境</span></span><br><span class="line">npm install                      <span class="comment">//安装必要组件</span></span><br></pre></td></tr></table></figure>
<p>此时就可以新建博客了</p>
<h2 id="3-_u521B_u5EFA_u535A_u5BA2"><a href="#3-_u521B_u5EFA_u535A_u5BA2" class="headerlink" title="3.创建博客"></a>3.创建博客</h2><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> page <span class="string">'&lt;blog title&gt;'</span>     <span class="comment">//会在/source/_posts/生成相应的文件文件夹</span></span><br><span class="line">编辑<span class="keyword">index</span>.md即可</span><br></pre></td></tr></table></figure>
<p>或者直接发布到_post:<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> &lt;blog name&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="4-_u53D1_u5E03_u65B9_u6CD5"><a href="#4-_u53D1_u5E03_u65B9_u6CD5" class="headerlink" title="4.发布方法"></a>4.发布方法</h2><h3 id="1-_u53D1_u5E03_u5728_u4E91_u4E0A"><a href="#1-_u53D1_u5E03_u5728_u4E91_u4E0A" class="headerlink" title="1.发布在云上"></a>1.发布在云上</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">g</span> &amp;&amp; hexo s               <span class="comment">//生成博客，并开始启动服务</span></span><br></pre></td></tr></table></figure>
<p>此时访问云分配给你的<em><a href="http://域名:4000/" target="_blank" rel="external">http://域名:4000/</a></em>即可看到你的博客</p>
<h3 id="2-_u53D1_u5E03_u5728Github"><a href="#2-_u53D1_u5E03_u5728Github" class="headerlink" title="2.发布在Github"></a>2.发布在Github</h3><ol>
<li>在自己的github上建立一个与用户名相同的repo</li>
<li>在repo <code>Settings</code>中选择开启<code>Github Pages</code></li>
<li><p>由于之前安装了hexo-deploy-git,因此只要配置git config即可</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user<span class="class">.name</span> <span class="string">"your github name"</span></span><br><span class="line">git config --global user<span class="class">.email</span> <span class="string">"you github email"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改本地站点下的<em>/_config.xml</em>,找到<em>deploy</em>:</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">deploy</span>:</span><br><span class="line">  <span class="attribute">type</span>: git</span><br><span class="line">  <span class="attribute">message</span>: <span class="string">"update blog."</span></span><br><span class="line">  <span class="attribute">repo</span>: </span><br><span class="line">    <span class="attribute">github</span>: git<span class="variable">@github</span>.<span class="attribute">com</span>:your-name/youn-name.github.io.git</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>注意:这里不是网上所说的那种配置方式:</strong><br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">deploy</span>:</span><br><span class="line">  <span class="attribute">type</span>: github</span><br><span class="line">  <span class="attribute">repo</span>: git<span class="variable">@github</span>.<span class="attribute">com</span>:luoyibu/luoyibu.github.io.git</span><br><span class="line">  <span class="attribute">branch</span>: master</span><br></pre></td></tr></table></figure></p>
<p>当然，这种方式也可以，不过一次发布到2个及以上的托管服务会有问题，所以还是<br>使用新方法吧!</p>
<ol>
<li>发布博客<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">发布之前，最好清理本地环境：</span><br><span class="line">hexo clean</span><br><span class="line"></span><br><span class="line">生成并发布：</span><br><span class="line">hexo <span class="keyword">d</span> -<span class="keyword">g</span>   <span class="comment">//与 hexo g -d 相同</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="3-_u53D1_u5E03_u5728Gitcafe"><a href="#3-_u53D1_u5E03_u5728Gitcafe" class="headerlink" title="3.发布在Gitcafe"></a>3.发布在Gitcafe</h3><p>由于github在国外，国内访问不稳定，可以使用国内服务gitcafe,操作步骤也差不多。<br>这里提一下提前准备的东西。</p>
<ol>
<li>最好使用和github同名的账户，我就是这么干的，这样全局<code>git config</code>就是一样的，省去<br>一些麻烦。然后新建一个同用户名的repo</li>
<li><p>在~/.ssh下生成ssh密钥:</p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -<span class="keyword">C</span> <span class="string">"邮箱地址"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>copy id_rsa.pub中内容到github和gitcafe <code>SSH</code> 公钥管理中</p>
</li>
<li>修改本地站点下的<em>/_config.xml</em>,找到<em>deploy</em>:<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">deploy</span>:</span><br><span class="line">  <span class="attribute">type</span>: git</span><br><span class="line">  <span class="attribute">message</span>: <span class="string">"update blog."</span></span><br><span class="line">  <span class="attribute">repo</span>: </span><br><span class="line">    <span class="attribute">gitcafe</span>: git<span class="variable">@gitcafe</span>.<span class="attribute">com</span>:your-name/your-name.git</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>这里和网上教程介绍的也不一样,不需要brach: gitcafe-pages也能成功。</strong><br>之后发布操作和github发布相同，就不再赘述。</p>
<h2 id="Github_u548CGitcafe_u540C_u65F6_u53D1_u5E03"><a href="#Github_u548CGitcafe_u540C_u65F6_u53D1_u5E03" class="headerlink" title="Github和Gitcafe同时发布"></a>Github和Gitcafe同时发布</h2><p>github访问不稳定,gitcafe又快，为了国际化，能不能两个都发布呢?相信很多人和我<br>的想法一样，我找了很多资料，就连写makefile的都有，现在新版，同时发布已经很方便了。<br>网上大部分的是:<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">修改本地站点下的<span class="keyword">*</span>/_config.xml<span class="keyword">*</span>,修改<span class="keyword">*</span>deploy<span class="keyword">*</span>:</span><br><span class="line"></span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  message: [message]</span><br><span class="line">  repo:</span><br><span class="line">    github: <span class="variable">&lt;repository url&gt;</span>,master</span><br><span class="line">    gitcafe: <span class="variable">&lt;repository url&gt;</span>,gitcafe-pages</span><br></pre></td></tr></table></figure></p>
<p>这种在新版中经过我测试是不行的，github 的master分支一直出错，只有gitcage能成功。</p>
<p><strong>新版方法</strong><br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">deploy</span>:</span><br><span class="line">  <span class="attribute">type</span>: git</span><br><span class="line">  <span class="attribute">message</span>: <span class="string">"update blog."</span></span><br><span class="line">  <span class="attribute">repo</span>: </span><br><span class="line">    <span class="attribute">github</span>: git<span class="variable">@github</span>.<span class="attribute">com</span>:your-name/your-name.github.io.git</span><br><span class="line">    <span class="attribute">gitcafe</span>: git<span class="variable">@gitcafe</span>.<span class="attribute">com</span>:your-name/your-name.git</span><br></pre></td></tr></table></figure></p>
<p>不需要设置brach,两个发布都会成功。</p>
<hr>
<h2 id="5-_u5176_u4ED6_u6709_u7528_u7684_u64CD_u4F5C"><a href="#5-_u5176_u4ED6_u6709_u7528_u7684_u64CD_u4F5C" class="headerlink" title="5.其他有用的操作"></a>5.其他有用的操作</h2><h3 id="u6539_u53D8_u535A_u5BA2_u7684_u4E3B_u9898_u989C_u8272"><a href="#u6539_u53D8_u535A_u5BA2_u7684_u4E3B_u9898_u989C_u8272" class="headerlink" title="改变博客的主题颜色"></a>改变博客的主题颜色</h3><ul>
<li>由于使用的主题惨白的，对我来说是比较难看清内容的，所以我开始折腾<br>怎么换主题，去看原作者，发现他语焉不详，只提了一下solarized dark和highlightjs<br>高亮。然后昨晚对比css忙活到大半夜也没有成功。</li>
<li>今天仔细搜了下发现hexo3以上版本用的就是highlightjs,并且node_modules里已经有<br>stylus插件了，所以尝试了在theme中的config定义theme_color为常用sublime配色,果然成功了!</li>
</ul>
<p>现在记录下来以帮助那些还在惨白主题中苦苦挣扎的程序员吧!</p>
<ul>
<li>可以去highlightjs官网的<a href="https://highlightjs.org/static/demo/" target="_blank" rel="external">demo</a>选择自己喜欢的主题</li>
<li>在<em><your theme="">/_config.yml</your></em>添加:<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">theme_color</span>:</span><br><span class="line">    <span class="attribute">theme</span>: <span class="string">"Monokai Sublime"</span> <span class="comment">//你的主题名字</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>重新部署博客就可以看到新主题生效了，再也不用盯着惨白色看博客。</p>
<h3 id="u535A_u5BA2_u5220_u9664"><a href="#u535A_u5BA2_u5220_u9664" class="headerlink" title="博客删除"></a>博客删除</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">删除仓库里面 source/_posts/我的文章.md</span><br><span class="line"></span><br><span class="line">执行下面命令更新博客</span><br><span class="line"></span><br><span class="line">hexo g == hexo generate<span class="preprocessor">#生成</span></span><br><span class="line">hexo s == hexo <span class="keyword">server</span> <span class="preprocessor">#启动服务预览</span></span><br><span class="line">hexo d == hexo deploy<span class="preprocessor">#部署</span></span><br></pre></td></tr></table></figure>
<h3 id="u6DFB_u52A0_u5206_u7C7B/tags"><a href="#u6DFB_u52A0_u5206_u7C7B/tags" class="headerlink" title="添加分类/tags"></a>添加分类/tags</h3><h4 id="u65B0_u5EFA_u5206_u7C7B_3A"><a href="#u65B0_u5EFA_u5206_u7C7B_3A" class="headerlink" title="新建分类:"></a>新建分类:</h4><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> page <span class="string">"&lt;category name&gt;"</span></span><br></pre></td></tr></table></figure>
<p>在生成的相应md中修改如下:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">title: &lt;文章标题&gt;</span><br><span class="line">date: <span class="number">2016</span>-<span class="number">01</span>-<span class="number">09</span> <span class="number">10</span>:<span class="number">56</span>:<span class="number">27</span></span><br><span class="line">type: <span class="string">"&lt;category name&gt;"</span></span><br></pre></td></tr></table></figure></p>
<p>修改本地layour下的<em>/themes/<your-them>/_config.xml</your-them></em>，找到<em>menu</em>:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">menu</span>:</span><br><span class="line">  main: /</span><br><span class="line">  archives: /archives</span><br><span class="line">  category: /&lt;category name&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="u65B0_u5EFAtags"><a href="#u65B0_u5EFAtags" class="headerlink" title="新建tags"></a>新建tags</h4><p>直接在新建的md文件中添加<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">tag</span><span class="variable">s:</span> &lt;your <span class="keyword">tag</span> name&gt;</span><br></pre></td></tr></table></figure></p>
<p>修改本地layour下的<em>/themes/<your-them>/_config.xml</your-them></em>，添加:<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">tag</span><span class="variable">s:</span> /&lt;your <span class="keyword">tag</span> name&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="u6539_u53D8_u65B0_u5EFA_u535A_u5BA2_u7684_u6A21_u677F"><a href="#u6539_u53D8_u65B0_u5EFA_u535A_u5BA2_u7684_u6A21_u677F" class="headerlink" title="改变新建博客的模板"></a>改变新建博客的模板</h3><p>修改<em><your site="">/scaffolds/</your></em>下相应的文件即可:<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">post.md  =<span class="function">=&gt;</span>  对应hexo <span class="keyword">new</span> 生成的md模板</span><br><span class="line">page.md  =<span class="function">=&gt;</span>  对应hexo <span class="keyword">new</span> page生成的categories模板</span><br></pre></td></tr></table></figure></p>
<p>可以在其中加上<code>categories:</code>模板，这样就不用每次手动添加了。<br>例如:<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">title:</span> <span class="expansion">&#123;&#123; title &#125;&#125;</span></span><br><span class="line"><span class="symbol">author:</span> <span class="expansion">&#123;&#123; your-name &#125;&#125;</span>  /<span class="regexp">/添加的模板</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags:</span></span><br></pre></td></tr></table></figure></p>
<h1 id="u6700_u540E"><a href="#u6700_u540E" class="headerlink" title="最后"></a>最后</h1><p>　　今天通过这种方法，我在<a href="https://linghutf.github.io/" target="_blank" rel="external">github</a>和<a href="http://linghutf.gitcafe.com" target="_blank" rel="external">gitcafe</a>上的博客<br>都正常运行了，也是经经历一番排错和查找问题的经历。<br>　　其实有些东西自己摸索出来还是很有成就感的，印象也更深，即使是别人早已知道的。<br>希望给想建立自己博客的人一点帮助。后续遇到的一些问题都会在博客上更新，<br>欢迎关注<a href="https:://linghutf.gitcafe.com/" target="_blank" rel="external">我</a>!</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u9759_u6001_u535A_u5BA2_u642D_u5EFA"><a href="#u9759_u6001_u535A_u5BA2_u642D_u5EFA" class="headerlink" title="静态博客搭建"></a>静态博客搭建</h1]]>
    </summary>
    
      <category term="tools" scheme="http://linghutf.gitcafe.io/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于合适语言的一点看法]]></title>
    <link href="http://linghutf.gitcafe.io/2016/01/09/languages/"/>
    <id>http://linghutf.gitcafe.io/2016/01/09/languages/</id>
    <published>2016-01-09T00:31:03.000Z</published>
    <updated>2016-01-11T14:06:48.000Z</updated>
    <content type="html"><![CDATA[<h1 id="u8BED_u8A00_u4E4B_u4E89"><a href="#u8BED_u8A00_u4E4B_u4E89" class="headerlink" title="语言之争"></a>语言之争</h1><p>每当一种语言诞生，世界上的争吵就多了一种声音。经常可见这样的讨论:<br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"xxx就不错，yyy是垃圾，这都不支持!"</span></span><br><span class="line"><span class="string">"xxx太复杂了，不适合如今的应用模式。"</span></span><br><span class="line"><span class="string">"xxx是最好的语言。"</span></span><br><span class="line">....</span><br></pre></td></tr></table></figure></p>
<p>我大学期间也自学很多语言，主要是想做个东西出来，看别人推荐什么语言，有什么现成的库，<br>就开始了入坑之旅。</p>
<ul>
<li>从那以后，我就开始用python写爬虫抓音乐链接，书籍，还写了一些获取ss节点的程序，运行更新节点信息，<br>就可以很方便上外网了。感兴趣的可以移步我的github:<a href="https://github.com/linghutf/shadowsocks-config-graber.git" target="_blank" rel="external">ss-config-graber</a>,<br>xcode文档的真实下载地址:<a href="https://github.com/linghutf/XcodeDocDownload.git" target="_blank" rel="external">XcodeDocDownload</a></li>
<li>Java写过界面游戏，当时的数值算法这门课我都是用它完成作业，还有被写烂了的xxx管理系统，也正是Java，让我<br>开始使用数据库而不是用写文件读文件的方式。</li>
<li>c/c++写算法，数据结构，做OJ。往往一遍又一遍的去优化，看着用时又减少了就很开心。</li>
<li>后来Javascript居然可以写服务器端的应用，特别是express路由、模板、控制器简洁明了，路由注册拦截请求，调用中间件<br>处理数据，控制器控制由模型组成的数据去渲染模板。一个web系统就这样做完了，效率很高，所以当时写写回调也无所谓，还顺便<br>学习了前段的Ajax操作，那种处理和表现数据的感觉现在都印象深刻。所以正在上的工程数学的矩阵分解和一些统计方法我都想<br>办法写成js程序，放在手机里直接用。真的是到处运行。</li>
<li>学了golang后</li>
</ul>
<hr>
<h1 id="u5B66_u4E60_u5B8C_u8FD9_u4E9B_u4E3B_u6D41_u8BED_u8A00_u7684_u611F_u53D7"><a href="#u5B66_u4E60_u5B8C_u8FD9_u4E9B_u4E3B_u6D41_u8BED_u8A00_u7684_u611F_u53D7" class="headerlink" title="学习完这些主流语言的感受"></a>学习完这些主流语言的感受</h1><ul>
<li><p>Java写得冗长，框架笨重又得配置xml,但是一旦项目规模上来了，<br>它却是协作下表现最不差的解决方案。因此现在使用Java最广泛。<br>毕竟水平一般不知道控制代码质量和内存使用的人太多。</p>
</li>
<li><p>C没有类型系统，我看过一些为C添加的对象系统，使用宏如同魔法<br>一样，但是这种法案离C写基础构件的初衷还是很远，不是经历过正规<br>训练的人很难习惯和掌握什么都需要自己创造的环境。另外C的字符串<br>处理太弱，由于历史原因不支持UTF-8,这就在今天大部分的字符串处理<br>逻辑里带来不便。</p>
</li>
<li><p>C++在C的基础上添加了很多语法，字符串处理同样比较差，多种范式，<br>怎么写都有办法达到目的，写起来最不容易控制复杂性，或者是在中途为<br>了追求优雅高效而忘记了自己究竟要干什么。项目不是写到一半被抛弃，<br>或者重构的时候干脆从头开始造轮子了。</p>
</li>
<li><p>还有重要的一点是，C++的Bug最难找，由内存处置不当导致的错误层出<br>不穷，如果使用了高级特性如模板、迭代器、算子之后一旦出错错误信息<br>如果天书一样在屏幕上滚过，而你的一天就这样过去了。</p>
</li>
<li><p>我见过很多C++的拥趸说C++是最强的语言，什么都能做还能做得很好，<br>这点确实如此，但是这么一件强大的武器需要非常熟练它的人才能发挥出它<br>的功效，而不是写过只有几百行代码就莫名喜欢的人所认为的那样，也不是<br>指针不释放，内存到处申请的人就能自称熟练使用C++。</p>
</li>
<li><p>python写出的程序直观，最适合初期快速实现自己的想法。但是多线程GIL<br>的原因，重构社么的也麻烦，因为写的时候太自由了，同样不能充当主力，<br>而是作为干杂活的最佳选择，写出1.0版最快。</p>
</li>
<li><p>javascript异军突起，google的V8引擎功不可没，现在进本上基本上所有智<br>能设备都可以支持javascript，这就有了广泛的市场。但是它的异步特性使得<br>我们长期受到一步一步操作的思路影响的大脑有点难以接受，常常困惑于为什<br>么没有取到数据，那一层层的函数包裹搞得人连函数边界在哪都不知道。这就<br>限制了一般程序员的使用，对象和继承出现的问题也比较奇怪。总的来说在web<br>前后端还是不错的，一致的语言带来的是连贯的思路，思路清晰又往往可以保<br>证项目完工，半路失败的项目太多了。</p>
</li>
<li><p>PHP也略微了解一些，在web领域也是非Java就PHP了，简单易于掌握的才是最<br>好的，不管是个人开发者还是团队来说。最近准备了解Laravel框架，思路和<br>express一样，也是路由、控制器、模型，避免了之前写php的随心所欲，就像写<br>网页的php里面有连接数据库。其他领域基本就没有phph用武之地了。</p>
</li>
<li><p>golang语言2007才出现，其特点是足够简单，还有很好的一点是静态编译，没有<br>依赖问题。我之前认为动态编译的程序，内存中只有一份，节省内存，程度加载的也快，<br>静态编译不好，慢不说程序占用空间还大。但是今天IT行业已经变了，到处都是云环境，<br>CPU、内存、硬盘太多了，反而生产环境变得复杂了，一不小心某个依赖变了，应用就有<br>可能出问题，静态编译却没有这个主要困扰开发者的问题。用下来感觉挺不错的。缺点是<br>没有泛型，写通用操作不方便，传个interface{}感觉怪怪的，它的特色goroutine我用的<br>还不是很多，国内使用的案例也比较少，可能没有公开或者别人还在观望。也只有以后再<br>补充自己使用的感受了。强制统一的规范比如大写方法可以导出，用习惯了自觉地在其他<br>语言里也是用这种规范，而规范减少了出bug的可能。自带的测试命令也使得我写单元测试<br>保证正确性，以前写代码就是弄一两个数据测一下就算完事，而这种单元测试经常能发现边<br>界情况的错误，还有性能测试、代码覆盖度测试都可以保证代码是工程级而不是玩票性质。<br>最近就在写golang的常用的数据结构和算法库，也算是轮子吧，可以关注<a href="https://github.com/linghutf/utils.git" target="_blank" rel="external">utils</a><br>获取最新进展。</p>
</li>
</ul>
<h1 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h1><p>　　由于我接触的东西还不是很复杂，所以自己的这些看法难免会有一些错误的地方，之后随着阅<br>历的增加，感受自然会多起来。随着代码量的增长，我越来越觉得每种语言都有适合运用的场<br>景和劣势的地方，并不存在统一的万能解决方案，也不是以个人情绪来判断好坏。<br>　　我倾向的一种工作方式是，先用动态语言快速实现自己最重要的目标，之后可以将关键部分慢<br>慢升级换成Java这样的工业成熟方案，性能要求高的地方c/c++改写，让它们成为为应用提供服务的<br>组件。上层用户使用的地方javascript做初步操作，或者充当业务初步处理层。分布式的场景，<br>golang的通讯交换消息方式也有erlang先行者，性能非常出色。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u8BED_u8A00_u4E4B_u4E89"><a href="#u8BED_u8A00_u4E4B_u4E89" class="headerlink" title="语言之争"></a>语言之争</h1><p>每当一种语言诞生，世界上的争吵就多了一种声音。经]]>
    </summary>
    
      <category term="program language" scheme="http://linghutf.gitcafe.io/tags/program-language/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[大数阶乘截断]]></title>
    <link href="http://linghutf.gitcafe.io/2016/01/09/factor/"/>
    <id>http://linghutf.gitcafe.io/2016/01/09/factor/</id>
    <published>2016-01-08T21:12:36.000Z</published>
    <updated>2016-02-28T14:10:30.000Z</updated>
    <content type="html"><![CDATA[<h1 id="u9898_u76EE_u6765_u6E90"><a href="#u9898_u76EE_u6765_u6E90" class="headerlink" title="题目来源"></a>题目来源</h1><p>这是日本一个编程网站上的题，当时看别人介绍的时候，说每通过一道题，就可以给<br>动漫女性角色换一件衣服或装饰，这道题是比较难的，也是”奖励”最重的一道，做完基本<br>就通关了。话说这种方式还比较新颖，对那些死宅的程序员来说，诱惑很大。<br>若有兴趣，可以移步<a href="https://paiza.jp/poh/ando" target="_blank" rel="external">Get a girl friend in programing</a>。</p>
<h2 id="u91CC_u9762_u90FD_u662F_u65E5_u6587_uFF0C_u6211_u90FD_u662F_u8FDE_u8499_u5E26_u731C_u624D_u6210_u529F_u505A_u5230_u6700_u540E_u4E00_u9898_u3002"><a href="#u91CC_u9762_u90FD_u662F_u65E5_u6587_uFF0C_u6211_u90FD_u662F_u8FDE_u8499_u5E26_u731C_u624D_u6210_u529F_u505A_u5230_u6700_u540E_u4E00_u9898_u3002" class="headerlink" title="里面都是日文，我都是连蒙带猜才成功做到最后一题。"></a>里面都是日文，我都是连蒙带猜才成功做到最后一题。</h2><h1 id="u9898_u76EE_u63CF_u8FF0"><a href="#u9898_u76EE_u63CF_u8FF0" class="headerlink" title="题目描述"></a>题目描述</h1><p><strong>0&lt;=n&lt;=1000000,求n!去除末尾所有0之后的后9位数字，其中9位数字中若以0开头,则去掉0,剩下的数字即为结果</strong>。<br>例如:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span>!=<span class="number">3628800</span> =&gt; 去掉末尾<span class="number">0</span>，变成<span class="number">36288</span></span><br><span class="line"><span class="number">38</span>!=<span class="number">523022617466601111760007224100074291200000000</span> </span><br><span class="line">=&gt; 去掉<span class="number">0</span>,取<span class="number">9</span>位数字，得到<span class="number">000742912</span>，</span><br><span class="line">=&gt; 去掉开头的<span class="number">0</span>,得到最后结果<span class="number">742912</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="u89E3_u6CD5_u5386_u7A0B"><a href="#u89E3_u6CD5_u5386_u7A0B" class="headerlink" title="解法历程"></a>解法历程</h1><h2 id="u601D_u8DEF1-0"><a href="#u601D_u8DEF1-0" class="headerlink" title="思路1.0"></a>思路1.0</h2><ul>
<li>一开始我的想法是用Python快速写出来，Python自带大数计算，内存有多大就支持多大的数计算，<br>不用做转换或者其他的库，这也是很多科研学科使用的语言，比较容易上手。我的想法是:<ol>
<li>利用math.factorial(n)得到完整的结果</li>
<li>将结果转换成字符串，去掉末尾的0</li>
<li>若剩余大于9位，截取字符串后9位</li>
<li>最后去掉开头的0，得到结果</li>
</ol>
</li>
</ul>
<p>这种解法大概是人看到的第一反应了。python2代码如下:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*--- coding:utf-<span class="number">8</span> ---</span><br><span class="line">import math</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    n=<span class="function"><span class="title">int</span><span class="params">(input()</span></span>)</span><br><span class="line">    r=math.<span class="function"><span class="title">factorial</span><span class="params">(n)</span></span></span><br><span class="line">    s=<span class="function"><span class="title">str</span><span class="params">(r)</span></span>.<span class="function"><span class="title">rstrip</span><span class="params">(<span class="string">'0'</span>)</span></span></span><br><span class="line">    print <span class="function"><span class="title">int</span><span class="params">(s[-<span class="number">9</span>:])</span></span></span><br></pre></td></tr></table></figure></p>
<p>是不是很简单，但是python写起来效率高，性能就差了，在我的服务器上到<br>n=100000性能就不行了，以下是测试结果:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">服务器配置:E5-<span class="number">2620</span> <span class="number">2.00</span>GHz</span><br><span class="line">内存:<span class="number">16</span>GB</span><br></pre></td></tr></table></figure></p>
<p><img src="http://7xr8se.com1.z0.glb.clouddn.com/fact10000.png" alt="fact10000"></p>
<h2 id="u8FD9_u79CD_u5199_u6CD5_u5728OJ_u4E0A_u80AF_u5B9A_u8D85_u65F6_uFF0C_u9700_u8981_u6362_u601D_u8DEF_uFF0C_u5E76_u4E14_u6362_u4E00_u95E8_u7F16_u8BD1_u7C7B_u578B_u7684_u8BED_u8A00_u3002"><a href="#u8FD9_u79CD_u5199_u6CD5_u5728OJ_u4E0A_u80AF_u5B9A_u8D85_u65F6_uFF0C_u9700_u8981_u6362_u601D_u8DEF_uFF0C_u5E76_u4E14_u6362_u4E00_u95E8_u7F16_u8BD1_u7C7B_u578B_u7684_u8BED_u8A00_u3002" class="headerlink" title="这种写法在OJ上肯定超时，需要换思路，并且换一门编译类型的语言。"></a>这种写法在OJ上肯定超时，需要换思路，并且换一门编译类型的语言。</h2><h2 id="u601D_u8DEF2-0"><a href="#u601D_u8DEF2-0" class="headerlink" title="思路2.0"></a>思路2.0</h2><ul>
<li>自己手动控制阶乘流程，一旦结果结尾有0产生，立即去掉。</li>
<li>进一步改进，一旦乘数包含2和5因子，将出现次数记录下来，一个2抵消一个5，而不参与乘法，<br>这样就不会有结尾0出现，最后再将剩余的2或者5还原结果，这样对中间数字有影响。</li>
<li>对结果同样保留9位，去除开头的0</li>
</ul>
<h3 id="u9009_u5B9A_u8BED_u8A00"><a href="#u9009_u5B9A_u8BED_u8A00" class="headerlink" title="选定语言"></a>选定语言</h3><p>解法和语言没有太大关系，主要是选择一个自己用的顺手的语言。</p>
<ul>
<li>考虑过使用c,但是它的大数需要自己定义成数组，然后模拟乘法去做，比较繁琐，可以备用到后期改写。</li>
<li>C++太复杂，写一部分调试可能就要花掉很多时间，暂时不考虑。</li>
<li>Java很久没碰了，语法也比较啰嗦，写起来估计效果和C的差不多。</li>
</ul>
<p>可能我就是需要一个自带的大数运算，后来发现<a href="http://golang.org" target="_blank" rel="external">golang</a>不错,google里的三位大牛创造的，<br>专门为了解决工程中的一些现有的问题而产生的，熟悉了一下语法，明显是在向C语言致敬(<em>好像其中有写K&amp;R那本书的作者</em>)，<br>想做分布式系统时代的”C语言”,没有继承泛型，很容易上手，之后我会写博客讲讲Go。</p>
<p>golang实现这个思路后，我为了充分利用硬件，使用了<code>goroutine</code>采用类似<code>map/reduce</code>的算法，分段式计算阶乘，<br>这样计算用时要少一些，主要代码如下:<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"math/big"</span></span><br><span class="line">	<span class="string">"strconv"</span></span><br><span class="line">	<span class="string">"strings"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">Count</span> struct &#123;</span><br><span class="line">	<span class="keyword">Two</span> int64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func dropTwoAndFive(<span class="keyword">n</span> int64, cnt *<span class="keyword">Count</span>) int64 &#123;</span><br><span class="line">	<span class="keyword">for</span> <span class="keyword">n</span>%2 == 0 &#123;</span><br><span class="line">		<span class="keyword">n</span> /= 2</span><br><span class="line">		cnt.<span class="keyword">Two</span>++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> <span class="keyword">n</span>%5 == 0 &#123;</span><br><span class="line">		<span class="keyword">n</span> /= 5</span><br><span class="line">		cnt.<span class="keyword">Two</span>--</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">n</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Recover(<span class="keyword">n</span> *big.Int, cnt *<span class="keyword">Count</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> cnt.<span class="keyword">Two</span> &gt; 0 &#123;</span><br><span class="line">		<span class="keyword">for</span> cnt.<span class="keyword">Two</span> &gt; 0 &#123;</span><br><span class="line">			<span class="keyword">n</span> = <span class="keyword">n</span>.Mul(<span class="keyword">n</span>, big.NewInt(2))</span><br><span class="line">			cnt.<span class="keyword">Two</span>--</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> cnt.<span class="keyword">Two</span> &lt; 0 &#123;</span><br><span class="line">		<span class="keyword">for</span> cnt.<span class="keyword">Two</span> &lt; 0 &#123;</span><br><span class="line">			<span class="keyword">n</span> = <span class="keyword">n</span>.Mul(<span class="keyword">n</span>, big.NewInt(5))</span><br><span class="line">			cnt.<span class="keyword">Two</span>++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="keyword">fact</span>(c chan&lt;- *big.Int, begin, end int64, cnt *<span class="keyword">Count</span>, wg *sync.WaitGroup) &#123;</span><br><span class="line">	defer wg.Done()</span><br><span class="line">	f := big.NewInt(1)</span><br><span class="line">	<span class="comment">//start specail cond.</span></span><br><span class="line">	<span class="keyword">if</span> begin == 0 &#123;</span><br><span class="line">		begin = 1</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> begin &gt;= end &#123;</span><br><span class="line">		c &lt;- <span class="literal">f</span></span><br><span class="line">		<span class="literal">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := begin; i &lt; end; i++ &#123;</span><br><span class="line">		f = f.Mul(f, big.NewInt(dropTwoAndFive(i, cnt)))</span><br><span class="line">	&#125;</span><br><span class="line">	c &lt;- <span class="literal">f</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Factorial(c chan int64, <span class="keyword">n</span> int64, w *sync.WaitGroup) &#123;</span><br><span class="line">	<span class="comment">//wait get result</span></span><br><span class="line">	defer w.Done()</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	NUM := int64(4)</span><br><span class="line"></span><br><span class="line">	f := big.NewInt(1)</span><br><span class="line"></span><br><span class="line">	per := <span class="keyword">n</span> / NUM</span><br><span class="line"></span><br><span class="line">	channels := make([]chan *big.Int, NUM+1)</span><br><span class="line">	cnts := make([]<span class="keyword">Count</span>, NUM+1)</span><br><span class="line"></span><br><span class="line">	wg.Add(int(NUM + 1))</span><br><span class="line">	<span class="keyword">for</span> i := int64(0); i &lt; NUM; i++ &#123;</span><br><span class="line">		channels[i] = make(chan *big.Int, 1)</span><br><span class="line">		go <span class="keyword">fact</span>(channels[i], i*per, (i+1)*per, &amp;(cnts[i]), &amp;wg)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	channels[NUM] = make(chan *big.Int, 1)</span><br><span class="line">	go <span class="keyword">fact</span>(channels[NUM], NUM*per, <span class="keyword">n</span>+1, &amp;(cnts[NUM]), &amp;wg)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//wait all calc channel</span></span><br><span class="line">	wg.Wait()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//slice to get result</span></span><br><span class="line">	done := 0</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		select &#123;</span><br><span class="line">		case res, ok := &lt;-channels[0]:</span><br><span class="line">			<span class="keyword">if</span> ok &#123;</span><br><span class="line">				<span class="comment">//log.Printf("channel[%d]res:%v\n", 0, res)</span></span><br><span class="line">				<span class="keyword">if</span> res.Cmp(big.NewInt(1)) != 0 &#123;</span><br><span class="line">					f = f.Mul(f, res)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">close</span>(channels[0])</span><br><span class="line">				done++</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		case res, ok := &lt;-channels[1]:</span><br><span class="line">			<span class="keyword">if</span> ok &#123;</span><br><span class="line">				<span class="comment">//log.Printf("channel[%d]res:%v\n", 1, res)</span></span><br><span class="line">				<span class="keyword">if</span> res.Cmp(big.NewInt(1)) != 0 &#123;</span><br><span class="line">					f = f.Mul(f, res)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">close</span>(channels[1])</span><br><span class="line">				done++</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		case res, ok := &lt;-channels[2]:</span><br><span class="line">			<span class="keyword">if</span> ok &#123;</span><br><span class="line">				<span class="comment">//log.Printf("channel[%d]res:%v\n", 2, res)</span></span><br><span class="line">				<span class="keyword">if</span> res.Cmp(big.NewInt(1)) != 0 &#123;</span><br><span class="line">					f = f.Mul(f, res)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">close</span>(channels[2])</span><br><span class="line">				done++</span><br><span class="line">			&#125;</span><br><span class="line">		case res, ok := &lt;-channels[3]:</span><br><span class="line">			<span class="keyword">if</span> ok &#123;</span><br><span class="line">				<span class="comment">//log.Printf("channel[%d]res:%v\n", 3, res)</span></span><br><span class="line">				<span class="keyword">if</span> res.Cmp(big.NewInt(1)) != 0 &#123;</span><br><span class="line">					f = f.Mul(f, res)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">close</span>(channels[3])</span><br><span class="line">				done++</span><br><span class="line">			&#125;</span><br><span class="line">		case res, ok := &lt;-channels[4]:</span><br><span class="line">			<span class="keyword">if</span> ok &#123;</span><br><span class="line">				<span class="comment">//log.Printf("channel[%d]res:%v\n", 4, res)</span></span><br><span class="line">				<span class="keyword">if</span> res.Cmp(big.NewInt(1)) != 0 &#123;</span><br><span class="line">					f = f.Mul(f, res)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">close</span>(channels[4])</span><br><span class="line">				done++</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> int64(done) == (NUM + 1) &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//recover</span></span><br><span class="line">	<span class="keyword">sum</span> := int64(0)</span><br><span class="line">	<span class="keyword">for</span> _, cnt := <span class="keyword">range</span> cnts &#123;</span><br><span class="line">		<span class="keyword">sum</span> += cnt.<span class="keyword">Two</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//log.Println("sum(2):", sum, "\torigin:", f)</span></span><br><span class="line"></span><br><span class="line">	Recover(f, &amp;<span class="keyword">Count</span>&#123;<span class="keyword">sum</span>&#125;)</span><br><span class="line">	s := f.<span class="literal">String</span>()</span><br><span class="line">	<span class="keyword">if</span> len(s) &gt; 9 &#123;</span><br><span class="line">		s = s[len(s)-9:]</span><br><span class="line">	&#125;</span><br><span class="line">	result, <span class="keyword">err</span> := strconv.ParseInt(s, 10, 64)</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</span><br><span class="line">		<span class="keyword">log</span>.Fatal(<span class="keyword">err</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	c &lt;- result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TrimZero(<span class="keyword">n</span> *big.Int) &#123;</span><br><span class="line">	s := strings.TrimRight(<span class="keyword">n</span>.<span class="literal">String</span>(), <span class="string">"0"</span>)</span><br><span class="line">	<span class="keyword">var</span> ok bool</span><br><span class="line">	<span class="keyword">n</span>, ok = <span class="keyword">n</span>.SetString(s, 10)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">log</span>.Fatal(<span class="string">"convert failed!"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	<span class="keyword">n</span> := int64(0)</span><br><span class="line">	fmt.Scanln(&amp;<span class="keyword">n</span>)</span><br><span class="line"></span><br><span class="line">	start := time.Now()</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(1)</span><br><span class="line">	<span class="comment">//cnt := new(Count)</span></span><br><span class="line">	c := make(chan int64, 1)</span><br><span class="line">	<span class="comment">//go fact(c, 1, n, cnt, &amp;wg)</span></span><br><span class="line">	go Factorial(c, <span class="keyword">n</span>, &amp;wg)</span><br><span class="line">	wg.Wait()</span><br><span class="line"></span><br><span class="line">	fmt.Println(&lt;-c, <span class="string">"time:"</span>, time.Now().Sub(start).Seconds())</span><br><span class="line">	<span class="keyword">close</span>(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译之后运行还是比较快的，测试的10000和100000如下:<br><img src="http://7xr8se.com1.z0.glb.clouddn.com/gofact10000.png" alt="gofact-10000"></p>
<p>这种方式在网站上运行时只得了60分，超过3秒就超时，估计OJ系统用了上限去测试。<br>因此只能继续改进算法。</p>
<h2 id="u601D_u8DEF3-0"><a href="#u601D_u8DEF3-0" class="headerlink" title="思路3.0"></a>思路3.0</h2><p>这种解法就是用一个9位的数组模拟乘法运算，继续之前丢掉0的策略，结果超出9位的<br>部分也丢掉，这样自然就很快了，但是实际测试的时候发现数字计算有的不对。</p>
<h2 id="u770B_u6765_u8FD8_u8981_u601D_u8003_u51C6_u786E_u6027_u7684_u95EE_u9898_u51FA_u5728_u54EA_u3002"><a href="#u770B_u6765_u8FD8_u8981_u601D_u8003_u51C6_u786E_u6027_u7684_u95EE_u9898_u51FA_u5728_u54EA_u3002" class="headerlink" title="看来还要思考准确性的问题出在哪。"></a>看来还要思考准确性的问题出在哪。</h2><h1 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h1><p>写这篇博文只是做一个暂时性的总结，毕竟问题还没有达到要求。<br>因为这道题，我开始接触了golang,之前一直排斥这种怪异的语法，现在则看得开了，觉得<br>什么的场景合适什么特点的语言。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u9898_u76EE_u6765_u6E90"><a href="#u9898_u76EE_u6765_u6E90" class="headerlink" title="题目来源"></a>题目来源</h1><p>这是日本一个编程网站上的题，当时看别人介绍的时候]]>
    </summary>
    
      <category term="algorithm" scheme="http://linghutf.gitcafe.io/tags/algorithm/"/>
    
      <category term="go" scheme="http://linghutf.gitcafe.io/tags/go/"/>
    
      <category term="python" scheme="http://linghutf.gitcafe.io/tags/python/"/>
    
  </entry>
  
</feed>
